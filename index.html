<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,height=device-height,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
  <title>Nebula Meteor Adventure</title>
  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:#000;touch-action:none;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
    canvas{display:block}

    #ui{
      position:fixed;left:12px;top:12px;z-index:10;
      background:rgba(18,18,26,.62);backdrop-filter:blur(10px);
      border-radius:14px;padding:12px;color:#fff;font-size:12px;line-height:1.25;
      max-width:min(420px,92vw)
    }
    #ui b{font-size:13px}
    #ui .row{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
    #ui button{
      background:#24242e;border:0;color:#fff;border-radius:10px;padding:8px 10px;font-size:12px
    }
    #ui button:active{transform:scale(.98)}
    #hud{
      position:fixed;left:12px;bottom:12px;z-index:10;
      color:#bbb;font-size:12px;opacity:.85;background:rgba(0,0,0,.35);
      padding:8px 10px;border-radius:12px;backdrop-filter:blur(10px)
    }
    #love{
      position:fixed;left:50%;top:62%;
      transform:translate(-50%,-50%);
      z-index:11;color:#fff;font-size:18px;text-align:center;
      padding:14px 16px;border-radius:18px;
      background:rgba(0,0,0,.45);backdrop-filter:blur(10px);
      max-width:min(560px,90vw);
      opacity:0;pointer-events:none;
      transition:opacity .25s ease;
      text-shadow:0 8px 22px rgba(0,0,0,.85);
    }
    #love small{display:block;font-size:12px;color:#ddd;opacity:.85;margin-top:6px}

    #err{
      position:fixed;inset:0;display:none;align-items:center;justify-content:center;
      background:#0b0b10;color:#fff;z-index:9999;padding:20px;text-align:left
    }
    #err pre{
      white-space:pre-wrap;background:rgba(255,255,255,.06);padding:14px;border-radius:12px;
      max-width:900px;width:100%
    }
  </style>
</head>
<body>

<div id="ui">
  <b>üåå Nebula Meteor Adventure (3D, 9:16)</b><br>
  ‚Ä¢ Drag = puter ‚Ä¢ Pinch = zoom ‚Ä¢ Tap meteor = fokus + follow<br>
  ‚Ä¢ Render hemat: <b>20 meteor terdekat</b><br>
  <div class="row">
    <button id="btnPlay">‚ñ∂ Play</button>
    <button id="btnPause">‚è∏ Pause</button>
    <button id="btnAuto">üß≠ Auto Tour: OFF</button>
    <button id="btnShuffle">üé≤ Shuffle</button>
    <button id="btnFS">‚õ∂ Fullscreen</button>
  </div>
  <div class="row">
    <button id="btnRec">üé• Record</button>
    <button id="btnStop" disabled>‚èπ Stop</button>
  </div>
</div>

<div id="love"></div>
<div id="hud">Loading‚Ä¶</div>
<div id="err"><pre id="errTxt"></pre></div>

<audio id="music" src="music.mp3" loop></audio>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>
(() => {
  const hud = document.getElementById("hud");
  const loveBox = document.getElementById("love");
  const music = document.getElementById("music");
  const errWrap = document.getElementById("err");
  const errTxt = document.getElementById("errTxt");

  function showErr(e){
    console.error(e);
    errWrap.style.display="flex";
    errTxt.textContent =
`‚ö†Ô∏è Error (kalau layar putih / aneh):
${(e && (e.stack||e.message)) ? (e.stack||e.message) : String(e)}

Checklist cepat:
1) fotos/1.jpg ... fotos/N.jpg
2) music.mp3 di root
3) TOTAL_PHOTO harus sesuai jumlah foto
4) buka link pakai ?v=999 (hapus cache)
`;
  }

  try {
    /* ================= CONFIG ================= */
    const TOTAL_PHOTO   = 43;     // ganti ke 55 kalau 55
    const MAX_RENDER    = 20;     // hemat HP
    const METEOR_COUNT  = 1400;   // data saja (bukan mesh semua)
    const PHOTO_ASPECT  = 9/16;   // portrait
    const BASE_H        = 28;     // ukuran dasar meteor foto
    const R_MIN         = 180;
    const R_MAX         = 620;
    const ORBIT_SPEED   = 0.00045;

    /* ========== TEKS ROMANTIS (VARIASI) ========== */
    const romancePool = [
      "Aku peduli sama dirimu. ‚ù§Ô∏è",
      "Kalau kamu capek, aku di sini. ü§ç",
      "Aku suka cara kamu bertahan sejauh ini. üåô",
      "Pasti aku dibilang buaya karna bikin gini. Buaya mana yang mau capek-capek bikin gini? üòí",
      "Di antara semua wanita, aku tetap milih kamu. ‚ú®",
      "Kamu kayak anak kecil di mata ku yang bikin hari aku penuh semangat. üéÅ",
      "Jangan pergi jauh ya‚Ä¶ aku nyaman sama kamu. ü´∂",
      "Aku bakal berusaha bikin kamunya bahagia",
      "Aku nggak sempurna, tapi sayangku serius. ‚ù§Ô∏è‚Äçüî•",
      "Kamu cantik‚Ä¶ tapi yang paling aku suka: hatimu. ü§ç"
    ];

    // kalau mau teks spesifik per foto, isi di sini:
    // contoh: loveMap[11] = "Teks khusus buat foto 11 ‚ù§Ô∏è";
    const loveMap = {};
    // loveMap[11] = "Aku beneran sayang sama mu. ‚ù§Ô∏è";

    function getLoveLine(photoId){
      if(loveMap[photoId]) return loveMap[photoId];
      const idx = (photoId * 37 + 11) % romancePool.length; // deterministic tapi beda-beda
      return romancePool[idx];
    }

    /* ================= UI / AUDIO ================= */
    document.getElementById("btnPlay").onclick = () => music.play().catch(()=>{});
    document.getElementById("btnPause").onclick = () => music.pause();

    let autoTour = false;
    const btnAuto = document.getElementById("btnAuto");
    btnAuto.onclick = () => {
      autoTour = !autoTour;
      btnAuto.textContent = `üß≠ Auto Tour: ${autoTour ? "ON" : "OFF"}`;
      if (autoTour) followIndex = -1;
      if(autoTour) loveBox.style.opacity = 0;
    };

    document.getElementById("btnFS").onclick = async () => {
      try {
        if(!document.fullscreenElement) await document.documentElement.requestFullscreen();
        else await document.exitFullscreen();
      } catch(e){}
    };

    /* ================= SCENE ================= */
    const scene = new THREE.Scene();

    const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:"high-performance" });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 1.6));
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    document.body.appendChild(renderer.domElement);

    // Camera rig supaya bisa "ngikut" target beneran
    const cameraRig = new THREE.Group();
    const cameraPivot = new THREE.Group();
    cameraRig.add(cameraPivot);
    scene.add(cameraRig);

    const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 14000);
    camera.position.set(0, 0, 840);
    cameraPivot.add(camera);

    addEventListener("resize", () => {
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    /* ================= LIGHT ================= */
    scene.add(new THREE.AmbientLight(0xffffff, 0.55));
    const key = new THREE.DirectionalLight(0xffffff, 0.75);
    key.position.set(800, 900, 700);
    scene.add(key);

    /* ================= NEBULA BACKGROUND (SHADER) =================
       Ini bikin nebula ALWAYS ada, gak hilang karena fog/sprite.
    */
    const bgGeo = new THREE.PlaneGeometry(2,2);
    const bgMat = new THREE.ShaderMaterial({
      depthWrite:false,
      depthTest:false,
      uniforms:{
        t:{value:0},
        aspect:{value:innerWidth/innerHeight}
      },
      vertexShader:`
        varying vec2 vUv;
        void main(){ vUv = uv; gl_Position = vec4(position,1.0); }
      `,
      fragmentShader:`
        precision highp float;
        varying vec2 vUv;
        uniform float t;
        uniform float aspect;

        float hash(vec2 p){ return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453); }
        float noise(vec2 p){
          vec2 i = floor(p), f = fract(p);
          float a = hash(i);
          float b = hash(i + vec2(1.0,0.0));
          float c = hash(i + vec2(0.0,1.0));
          float d = hash(i + vec2(1.0,1.0));
          vec2 u = f*f*(3.0-2.0*f);
          return mix(a,b,u.x) + (c-a)*u.y*(1.0-u.x) + (d-b)*u.x*u.y;
        }

        void main(){
          vec2 uv = vUv*2.0-1.0;
          uv.x *= aspect;

          float n1 = noise(uv*1.5 + vec2(t*0.02, -t*0.01));
          float n2 = noise(uv*3.2 + vec2(-t*0.015, t*0.02));
          float n3 = noise(uv*7.0 + vec2(t*0.01, t*0.012));

          float neb = smoothstep(0.15, 0.95, n1*0.55 + n2*0.35 + n3*0.10);

          vec3 colA = vec3(0.55, 0.18, 0.95); // ungu
          vec3 colB = vec3(0.10, 0.75, 0.95); // cyan
          vec3 colC = vec3(0.95, 0.25, 0.55); // pink

          vec3 col = mix(colA, colB, n2);
          col = mix(col, colC, n3*0.65);

          // vignette
          float v = 1.0 - smoothstep(0.2, 1.25, length(uv));
          col *= (0.22 + 0.85*neb) * (0.55 + 0.45*v);

          // stars
          float s = step(0.9972, hash(vUv*vec2(1200.0,800.0) + t));
          col += s * vec3(1.0);

          gl_FragColor = vec4(col, 1.0);
        }
      `
    });
    const bg = new THREE.Mesh(bgGeo, bgMat);
    bg.frustumCulled = false;
    scene.add(bg);

    /* ================= WORLD (3D debris) ================= */
    const world = new THREE.Group();
    scene.add(world);

    // Fog ringan biar depth kerasa (tapi bg nebula tetap aman karena shader)
    scene.fog = new THREE.FogExp2(0x000000, 0.00062);

    /* ================= METEOR DATA ================= */
    function rand3D(){
      // debris 3D tersebar (bukan ring rapih)
      const t = Math.random();
      const r = Math.sqrt(t*(R_MAX*R_MAX - R_MIN*R_MIN) + R_MIN*R_MIN);
      const a = Math.random()*Math.PI*2;

      const thickness = (Math.random()*2-1) * 220;
      const warp = (Math.random()*2-1) * 110;

      const x = Math.cos(a)*r + warp;
      const z = Math.sin(a)*r - warp;
      const y = thickness + Math.sin(a*2.3)*30;

      return {x,y,z,r,a};
    }

    const meteors = [];
    for(let i=0;i<METEOR_COUNT;i++){
      const p = rand3D();
      meteors.push({
        photoId: 1 + (i % TOTAL_PHOTO),
        x:p.x, y:p.y, z:p.z,
        r:p.r,
        ang:p.a,
        speed: (0.65 + Math.random()*1.2),
        rx: (Math.random()*2-1) * 0.9,
        ry: (Math.random()*2-1) * Math.PI,
        rz: (Math.random()*2-1) * 0.55,
        spin: (Math.random()*2-1) * 0.02,
        // velocity cache for trail
        vx:0, vy:0, vz:0,
        px:p.x, py:p.y, pz:p.z
      });
    }

    /* ================= LOAD TEXTURES ================= */
    const loader = new THREE.TextureLoader();
    const photoTex = new Array(TOTAL_PHOTO+1);
    let loaded = 0;

    for(let i=1;i<=TOTAL_PHOTO;i++){
      loader.load(`fotos/${i}.jpg`, (t)=>{
        t.colorSpace = THREE.SRGBColorSpace;
        t.anisotropy = 2;
        photoTex[i]=t;
        loaded++;
      });
    }

    /* ================= POOL 20 RECT 9:16 ================= */
    const geom = new THREE.PlaneGeometry(BASE_H*PHOTO_ASPECT, BASE_H, 1, 1);

    function makeMat(tex){
      return new THREE.MeshBasicMaterial({
        map: tex || null,
        transparent:true,
        opacity:1,
        side:THREE.DoubleSide,
        depthWrite:false
      });
    }

    // glow overlay
    const glowGeom = new THREE.PlaneGeometry(BASE_H*PHOTO_ASPECT*1.22, BASE_H*1.22, 1, 1);
    function glowMaterial(){
      return new THREE.MeshBasicMaterial({
        color:0xffffff,
        transparent:true,
        opacity:0.20,
        blending: THREE.AdditiveBlending,
        depthWrite:false
      });
    }

    // trail
    const trailGeom = new THREE.PlaneGeometry(BASE_H*PHOTO_ASPECT*0.7, BASE_H*2.7, 1, 1);
    function trailMaterial(){
      return new THREE.MeshBasicMaterial({
        color:0xa6f0ff,
        transparent:true,
        opacity:0.12,
        blending: THREE.AdditiveBlending,
        depthWrite:false
      });
    }

    const pool = [];
    const poolGlow = [];
    const poolTrail = [];

    for(let i=0;i<MAX_RENDER;i++){
      const m = new THREE.Mesh(geom, makeMat(null));
      m.visible = false;
      scene.add(m);
      pool.push(m);

      const g = new THREE.Mesh(glowGeom, glowMaterial());
      g.visible = false;
      scene.add(g);
      poolGlow.push(g);

      const tr = new THREE.Mesh(trailGeom, trailMaterial());
      tr.visible = false;
      scene.add(tr);
      poolTrail.push(tr);
    }

    /* ================= INPUT ROTATE + ZOOM ================= */
    let yaw = 0.25, pitch = 0.08;
    let dist = 840, targetDist = 840;

    let dragging=false, lastX=0, lastY=0;
    const dom = renderer.domElement;

    dom.addEventListener("pointerdown",(e)=>{
      dragging=true; lastX=e.clientX; lastY=e.clientY;
    });
    dom.addEventListener("pointermove",(e)=>{
      if(!dragging) return;
      const dx = e.clientX-lastX;
      const dy = e.clientY-lastY;
      yaw   -= dx*0.0042;
      pitch -= dy*0.0036;
      pitch = Math.max(-0.95, Math.min(0.95, pitch));
      lastX=e.clientX; lastY=e.clientY;

      // kalau user geser, batal follow biar gak "narik"
      followIndex = -1;
    });
    dom.addEventListener("pointerup",()=> dragging=false);
    dom.addEventListener("pointercancel",()=> dragging=false);

    // pinch zoom
    let lastPinch=null;
    dom.addEventListener("touchmove",(e)=>{
      if(e.touches.length!==2) return;
      e.preventDefault();
      const dx = e.touches[0].clientX - e.touches[1].clientX;
      const dy = e.touches[0].clientY - e.touches[1].clientY;
      const d = Math.hypot(dx,dy);
      if(lastPinch){
        const ratio = d/lastPinch;
        targetDist = THREE.MathUtils.clamp(targetDist/ratio, 220, 1800);
      }
      lastPinch = d;
    },{passive:false});
    dom.addEventListener("touchend",()=> lastPinch=null);

    /* ================= SHUFFLE ================= */
    document.getElementById("btnShuffle").onclick = ()=>{
      for(const m of meteors){
        const p = rand3D();
        m.x=p.x; m.y=p.y; m.z=p.z; m.r=p.r; m.ang=p.a;
        m.px=m.x; m.py=m.y; m.pz=m.z;
      }
      followIndex=-1;
      loveBox.style.opacity = 0;
    };

    /* ================= RAYCAST TAP -> FOLLOW ================= */
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let followIndex = -1;

    function pickTap(x,y){
      const rect = dom.getBoundingClientRect();
      mouse.x = ((x-rect.left)/rect.width)*2 - 1;
      mouse.y = -(((y-rect.top)/rect.height)*2 - 1);
      raycaster.setFromCamera(mouse, camera);

      const hits = raycaster.intersectObjects(pool, true);
      if(hits.length){
        const obj = hits[0].object;
        const pi = pool.indexOf(obj);
        if(pi>=0 && pool[pi].userData.dataIndex>=0){
          followIndex = pool[pi].userData.dataIndex;

          // zoom dekat (biar "full layar" tapi masih aman)
          targetDist = 260;
          autoTour = false;
          btnAuto.textContent = "üß≠ Auto Tour: OFF";

          // teks romantis sesuai foto
          const photoId = meteors[followIndex].photoId;
          const line = getLoveLine(photoId);
          loveBox.innerHTML = `${line}<small>(foto ${photoId}.jpg)</small>`;
          loveBox.style.opacity = 1;

          music.play().catch(()=>{});
        }
      }
    }

    let tapStart=null;
    dom.addEventListener("pointerdown",(e)=>{
      tapStart = {x:e.clientX,y:e.clientY,t:performance.now()};
    });
    dom.addEventListener("pointerup",(e)=>{
      if(!tapStart) return;
      const moved = Math.hypot(e.clientX-tapStart.x, e.clientY-tapStart.y);
      const dt = performance.now()-tapStart.t;
      if(moved<10 && dt<350) pickTap(e.clientX,e.clientY);
      tapStart=null;
    });

    /* ================= CAMERA FOLLOW (REAL) =================
       Kamera rig bakal "ngorbit" & pivot geser mendekati target.
    */
    const clock = new THREE.Clock();
    let tourTimer = 0;
    let tourTarget = Math.floor(Math.random()*meteors.length);

    // posisi pivot (target kamera) ‚Äî akan di-smooth
    const pivotPos = new THREE.Vector3(0,0,0);
    const targetPivot = new THREE.Vector3(0,0,0);

    function updateCamera(dt){
      dist = THREE.MathUtils.lerp(dist, targetDist, 0.10);
      camera.position.set(0, 0, dist);

      // rotate rig (yaw/pitch)
      cameraRig.rotation.y = yaw;
      cameraRig.rotation.x = pitch;

      // auto tour: jalan-jalan cari foto
      if(autoTour){
        yaw += 0.35*dt;
        pitch = THREE.MathUtils.lerp(pitch, Math.sin(clock.elapsedTime*0.35)*0.18, 0.02);

        tourTimer += dt;
        if(tourTimer > 2.6){
          tourTimer = 0;
          tourTarget = Math.floor(Math.random()*meteors.length);
          followIndex = tourTarget;
          targetDist = 300;
        }
      }

      // follow target (ini yang bikin kamera "ngikut")
      if(followIndex>=0){
        const m = meteors[followIndex];

        // target pivot menuju posisi meteor (world space)
        targetPivot.set(m.x, m.y, m.z);

        // supaya framing enak: geser sedikit ke depan arah meteor
        const n = targetPivot.clone().normalize().multiplyScalar(18);
        targetPivot.add(n);

        // arah rig juga diarahkan ke meteor
        const v = targetPivot.clone().normalize();
        const ty = Math.atan2(v.x, v.z);
        const tx = Math.asin(THREE.MathUtils.clamp(v.y, -1, 1));

        yaw   = THREE.MathUtils.lerp(yaw, ty, 0.06);
        pitch = THREE.MathUtils.lerp(pitch, -tx, 0.06);

        targetDist = THREE.MathUtils.lerp(targetDist, 260, 0.03);
      } else {
        // balik pivot pelan ke tengah (biar nebula tetep pusat)
        targetPivot.set(0,0,0);
      }

      // smooth pivot movement
      pivotPos.lerp(targetPivot, 0.08);
      cameraPivot.position.copy(pivotPos);

      // selalu lihat pivot (yang bergerak)
      camera.lookAt(cameraPivot.position);
    }

    /* ================= ORBIT + VELOCITY ================= */
    function updateMeteors(dt){
      for(const m of meteors){
        m.px=m.x; m.py=m.y; m.pz=m.z;

        m.ang += ORBIT_SPEED * m.speed * (dt*60);
        const rr = m.r + Math.sin(m.ang*2.4 + m.rx)*28;

        m.x = Math.cos(m.ang)*rr + Math.sin(m.ang*3.1)*26;
        m.z = Math.sin(m.ang)*rr + Math.cos(m.ang*2.7)*22;
        m.y = m.y*0.998 + Math.sin(m.ang*2.0 + m.ry)*0.30;

        m.ry += m.spin * (dt*60);

        const inv = 1/Math.max(dt, 0.0001);
        m.vx = (m.x-m.px)*inv;
        m.vy = (m.y-m.py)*inv;
        m.vz = (m.z-m.pz)*inv;
      }
    }

    /* ================= FIND 20 NEAREST & RENDER ================= */
    const camPos = new THREE.Vector3();
    const tmp = new THREE.Vector3();
    const tmpDir = new THREE.Vector3();

    function renderNearest(){
      camera.getWorldPosition(camPos);

      // cari 20 meteor terdekat dari kamera
      const arr = [];
      for(let i=0;i<meteors.length;i++){
        const m = meteors[i];
        tmp.set(m.x,m.y,m.z);
        const d2 = tmp.distanceToSquared(camPos);
        arr.push([d2,i,tmp.x,tmp.y,tmp.z]);
      }
      arr.sort((a,b)=>a[0]-b[0]);
      const nearest = arr.slice(0, MAX_RENDER);

      for(let p=0;p<MAX_RENDER;p++){
        const mesh = pool[p];
        const glow = poolGlow[p];
        const trail = poolTrail[p];

        const item = nearest[p];
        if(!item){ mesh.visible=glow.visible=trail.visible=false; continue; }

        const idx = item[1];
        const wx = item[2], wy = item[3], wz = item[4];
        const m = meteors[idx];

        mesh.userData.dataIndex = idx;

        const tex = photoTex[m.photoId];
        if(tex && mesh.material.map !== tex){
          mesh.material.map = tex;
          mesh.material.needsUpdate = true;
        }

        mesh.position.set(wx,wy,wz);
        mesh.rotation.set(m.rx, m.ry, m.rz);

        const distToCam = Math.sqrt(item[0]);

        // scale dekat -> besar, jauh -> kecil
        const scale = THREE.MathUtils.clamp(1.3 - (distToCam/820), 0.22, 1.15);
        mesh.scale.setScalar(scale);

        // fade jauh
        const alpha = THREE.MathUtils.clamp(1.0 - (distToCam/1300), 0.04, 1.0);
        mesh.material.opacity = alpha;
        mesh.visible = true;

        // glow
        glow.position.copy(mesh.position);
        glow.rotation.copy(mesh.rotation);
        glow.scale.setScalar(scale);
        glow.material.opacity = (idx===followIndex ? 0.45 : 0.22) * alpha;
        glow.visible = true;

        // ‚òÑÔ∏è trail (arah kebalikan velocity)
        tmpDir.set(m.vx,m.vy,m.vz);
        if(tmpDir.lengthSq() < 0.0001) tmpDir.set(0,0,1);
        tmpDir.normalize();

        const len = THREE.MathUtils.clamp((Math.abs(m.vx)+Math.abs(m.vy)+Math.abs(m.vz))*0.00032, 0.7, 3.2);

        trail.position.copy(mesh.position).addScaledVector(tmpDir, -14*scale);
        trail.lookAt(trail.position.clone().addScaledVector(tmpDir, -1));
        trail.scale.set(scale, scale*len, 1);
        trail.material.opacity = (idx===followIndex ? 0.18 : 0.12) * alpha;
        trail.visible = true;
      }

      // hud
      hud.textContent = `Loaded ${loaded}/${TOTAL_PHOTO} ‚Ä¢ Render 20/${METEOR_COUNT} ‚Ä¢ Zoom ${dist.toFixed(0)} ‚Ä¢ Follow ${followIndex>=0 ? (meteors[followIndex].photoId+".jpg") : "-"}`;
    }

    /* ================= RECORD WebM ================= */
    let mediaRecorder=null, recordedChunks=[];
    const btnRec = document.getElementById("btnRec");
    const btnStop = document.getElementById("btnStop");

    function downloadBlob(blob, filename){
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url; a.download = filename;
      document.body.appendChild(a);
      a.click(); a.remove();
      setTimeout(()=>URL.revokeObjectURL(url), 1500);
    }

    btnRec.onclick = () => {
      try{
        const stream = renderer.domElement.captureStream(30);
        recordedChunks=[];
        // vp9 -> kalau gagal nanti fallback
        mediaRecorder = new MediaRecorder(stream, { mimeType:"video/webm;codecs=vp9" });
        mediaRecorder.ondataavailable = e => { if(e.data && e.data.size) recordedChunks.push(e.data); };
        mediaRecorder.onstop = () => downloadBlob(new Blob(recordedChunks,{type:"video/webm"}), "nebula-meteor.webm");
        mediaRecorder.start();
        btnRec.disabled=true; btnStop.disabled=false;
      }catch(e){
        try{
          const stream = renderer.domElement.captureStream(30);
          recordedChunks=[];
          mediaRecorder = new MediaRecorder(stream, { mimeType:"video/webm;codecs=vp8" });
          mediaRecorder.ondataavailable = e => { if(e.data && e.data.size) recordedChunks.push(e.data); };
          mediaRecorder.onstop = () => downloadBlob(new Blob(recordedChunks,{type:"video/webm"}), "nebula-meteor.webm");
          mediaRecorder.start();
          btnRec.disabled=true; btnStop.disabled=false;
        }catch(err){
          alert("Browser kamu belum support record WebM üò≠\nCoba Chrome terbaru.");
        }
      }
    };

    btnStop.onclick = () => {
      if(mediaRecorder && mediaRecorder.state!=="inactive") mediaRecorder.stop();
      btnRec.disabled=false; btnStop.disabled=true;
    };

    /* ================= MAIN LOOP ================= */
    function animate(){
      requestAnimationFrame(animate);
      const dt = clock.getDelta();

      // nebula animate
      bgMat.uniforms.t.value = clock.elapsedTime;
      bgMat.uniforms.aspect.value = innerWidth/innerHeight;

      updateCamera(dt);
      updateMeteors(dt);
      renderNearest();

      // kalau follow, tampilkan love. Kalau tidak, fade
      if(followIndex>=0){
        const pid = meteors[followIndex].photoId;
        loveBox.innerHTML = `${getLoveLine(pid)}<small>(foto ${pid}.jpg)</small>`;
        loveBox.style.opacity = 1;
      } else {
        loveBox.style.opacity = 0;
      }

      renderer.render(scene, camera);
    }
    animate();

  } catch(e){
    showErr(e);
  }
})();
</script>
</body>
</html>
