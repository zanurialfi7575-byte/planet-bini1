<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Planet Foto (9:16 Cinematic)</title>
  <style>
    html, body { margin: 0; height: 100%; background: #000; overflow: hidden; }
    canvas { display: block; margin: 0 auto; background: #000; }

    /* UI minimal */
    .ui {
      position: fixed; left: 12px; top: 12px; z-index: 10;
      font-family: ui-monospace, Menlo, Consolas, monospace;
      color: rgba(255,255,255,.85);
      background: rgba(0,0,0,.35);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 14px;
      padding: 10px 12px;
      backdrop-filter: blur(10px);
      max-width: 320px;
    }
    .ui h3 { margin: 0 0 6px; font-size: 12px; font-weight: 700; letter-spacing: .3px; opacity: .9; }
    .ui .row { display: flex; gap: 8px; margin-top: 8px; }
    .ui button {
      flex: 1;
      cursor: pointer;
      border-radius: 12px;
      padding: 10px 10px;
      border: 1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.06);
      color: #fff;
      font-size: 12px;
    }
    .ui button:hover { background: rgba(255,255,255,.10); }
    .ui .mut { font-size: 11px; opacity: .75; line-height: 1.35; }
    .ui .pill {
      display: inline-block; margin-top: 6px;
      padding: 4px 8px; border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      font-size: 11px; opacity: .9;
    }
  </style>
</head>
<body>
  <div class="ui">
    <h3>üåç Planet Foto Cinematic (9:16)</h3>
    <div class="mut">
      - 10.000 foto (repeat dari 55)<br>
      - Glow nebula + bloom<br>
      - Beat sync (taruh <b>music.mp3</b>)<br>
      - Tekan tombol Play untuk musik
    </div>
    <div class="row">
      <button id="playBtn">‚ñ∂ Play Music</button>
      <button id="pauseBtn">‚è∏ Pause</button>
    </div>
    <div class="pill" id="beatPill">Beat: 0.00</div>
  </div>

<script type="module">
  import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
  import { EffectComposer } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js";
  import { RenderPass } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/RenderPass.js";
  import { UnrealBloomPass } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js";

  /* ===========================
     SETTINGS
     =========================== */
  const PHOTO_COUNT = 10000;     // üî• 10K
  const TEX_COUNT = 55;          // sumber foto cuma 55
  const ASPECT_W = 9, ASPECT_H = 16;   // üì± 9:16
  const USE_PIXEL_RATIO = true;        // true = lebih tajam tapi berat

  // Orbit tuning
  const RADIUS_MIN = 16;
  const RADIUS_MAX = 42;
  const HEIGHT_RANGE = 26;
  const BASE_SPEED_MIN = 0.0015;
  const BASE_SPEED_MAX = 0.0050;

  // Photo size
  const PHOTO_W = 1.6;
  const PHOTO_H = 2.25;

  // Planet
  const PLANET_RADIUS = 10.2;

  // Bloom (glow cinematic)
  let bloomStrength = 1.35;  // akan dipompa oleh beat
  let bloomRadius = 0.55;
  let bloomThreshold = 0.08;

  /* ===========================
     CANVAS / RENDER SIZE (9:16)
     =========================== */
  function getRenderSize() {
    // Fit 9:16 inside window without cropping
    const winW = window.innerWidth;
    const winH = window.innerHeight;
    const targetAspect = ASPECT_W / ASPECT_H;

    let w = winW;
    let h = Math.floor(w / targetAspect);
    if (h > winH) {
      h = winH;
      w = Math.floor(h * targetAspect);
    }
    return { w, h, aspect: targetAspect };
  }

  /* ===========================
     SCENE
     =========================== */
  const scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x000000, 0.015);

  const { w: initW, h: initH, aspect } = getRenderSize();
  const camera = new THREE.PerspectiveCamera(55, aspect, 0.1, 2000);
  camera.position.set(0, 6.5, 58);

  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
  renderer.setSize(initW, initH);
  renderer.setClearColor(0x000000, 1);
  if (USE_PIXEL_RATIO) renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
  document.body.appendChild(renderer.domElement);

  // Center canvas (since we‚Äôre fitting 9:16 inside screen)
  renderer.domElement.style.position = "fixed";
  renderer.domElement.style.left = "50%";
  renderer.domElement.style.top = "50%";
  renderer.domElement.style.transform = "translate(-50%, -50%)";

  /* ===========================
     POSTPROCESS: BLOOM
     =========================== */
  const composer = new EffectComposer(renderer);
  composer.addPass(new RenderPass(scene, camera));
  const bloomPass = new UnrealBloomPass(
    new THREE.Vector2(initW, initH),
    bloomStrength,
    bloomRadius,
    bloomThreshold
  );
  composer.addPass(bloomPass);

  /* ===========================
     LIGHTING (cinematic glow)
     =========================== */
  const ambient = new THREE.AmbientLight(0xffffff, 0.35);
  scene.add(ambient);

  const keyLight = new THREE.DirectionalLight(0x88ccff, 1.2);
  keyLight.position.set(20, 18, 22);
  scene.add(keyLight);

  const rimLight = new THREE.DirectionalLight(0xff66cc, 0.65);
  rimLight.position.set(-26, 8, -20);
  scene.add(rimLight);

  /* ===========================
     NEBULA (particles + gradient feel)
     =========================== */
  function makeNebula(count = 1800) {
    const geo = new THREE.BufferGeometry();
    const positions = new Float32Array(count * 3);
    const colors = new Float32Array(count * 3);

    const colorA = new THREE.Color(0x2cff9f);
    const colorB = new THREE.Color(0xbd93f9);
    const colorC = new THREE.Color(0x66d9ef);

    for (let i = 0; i < count; i++) {
      // Spread in big sphere around scene
      const r = 220 * Math.pow(Math.random(), 0.35);
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(2 * Math.random() - 1);

      const x = r * Math.sin(phi) * Math.cos(theta);
      const y = r * Math.cos(phi);
      const z = r * Math.sin(phi) * Math.sin(theta);

      positions[i*3+0] = x;
      positions[i*3+1] = y;
      positions[i*3+2] = z;

      // blend colors
      const t = Math.random();
      const c = (t < 0.33) ? colorA.clone().lerp(colorB, Math.random())
              : (t < 0.66) ? colorB.clone().lerp(colorC, Math.random())
              : colorC.clone().lerp(colorA, Math.random());

      colors[i*3+0] = c.r;
      colors[i*3+1] = c.g;
      colors[i*3+2] = c.b;
    }

    geo.setAttribute("position", new THREE.BufferAttribute(positions, 3));
    geo.setAttribute("color", new THREE.BufferAttribute(colors, 3));

    const mat = new THREE.PointsMaterial({
      size: 1.35,
      vertexColors: true,
      transparent: true,
      opacity: 0.65,
      depthWrite: false,
      blending: THREE.AdditiveBlending
    });

    const pts = new THREE.Points(geo, mat);
    return pts;
  }
  const nebula = makeNebula(2200);
  scene.add(nebula);

  /* ===========================
     PLANET (glowing)
     =========================== */
  const planetGeo = new THREE.SphereGeometry(PLANET_RADIUS, 96, 96);
  const planetMat = new THREE.MeshStandardMaterial({
    color: 0x0a0a12,
    emissive: 0x2cff9f,
    emissiveIntensity: 0.22,
    roughness: 0.85,
    metalness: 0.15
  });
  const planet = new THREE.Mesh(planetGeo, planetMat);
  scene.add(planet);

  // Extra ‚Äúglow shell‚Äù (fake atmosphere)
  const glowGeo = new THREE.SphereGeometry(PLANET_RADIUS * 1.05, 96, 96);
  const glowMat = new THREE.MeshBasicMaterial({
    color: 0x66d9ef,
    transparent: true,
    opacity: 0.12,
    blending: THREE.AdditiveBlending,
    depthWrite: false
  });
  const glowShell = new THREE.Mesh(glowGeo, glowMat);
  scene.add(glowShell);

  /* ===========================
     LOAD TEXTURES (55 fotos)
     =========================== */
  const loader = new THREE.TextureLoader();
  const textures = [];
  for (let i = 1; i <= TEX_COUNT; i++) {
    const tex = loader.load(`fotos/${i}.jpg`);
    tex.colorSpace = THREE.SRGBColorSpace;
    tex.anisotropy = Math.min(8, renderer.capabilities.getMaxAnisotropy());
    textures.push(tex);
  }

  /* ===========================
     10.000 PHOTOS using InstancedMesh (per texture)
     ‚úÖ performance-friendly
     =========================== */
  const basePlane = new THREE.PlaneGeometry(PHOTO_W, PHOTO_H);
  const instancedGroups = [];   // { mesh, params: {angle[], speed[], radius[], y[], tilt[] } }

  // distribute 10k among 55 textures
  const basePerTex = Math.floor(PHOTO_COUNT / TEX_COUNT);
  let remainder = PHOTO_COUNT - basePerTex * TEX_COUNT;

  const dummy = new THREE.Object3D();

  function rand(min, max){ return min + Math.random()*(max-min); }

  for (let t = 0; t < TEX_COUNT; t++) {
    const count = basePerTex + (remainder-- > 0 ? 1 : 0);
    const mat = new THREE.MeshBasicMaterial({
      map: textures[t],
      transparent: true,
      opacity: 0.95,
      depthWrite: false,
      blending: THREE.NormalBlending
    });

    const mesh = new THREE.InstancedMesh(basePlane, mat, count);
    mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    mesh.frustumCulled = false; // orbit wide

    // Params arrays
    const angle = new Float32Array(count);
    const speed = new Float32Array(count);
    const radius = new Float32Array(count);
    const y = new Float32Array(count);
    const tilt = new Float32Array(count);
    const spin = new Float32Array(count);

    for (let i = 0; i < count; i++) {
      angle[i] = Math.random() * Math.PI * 2;
      speed[i] = rand(BASE_SPEED_MIN, BASE_SPEED_MAX);
      radius[i] = rand(RADIUS_MIN, RADIUS_MAX);
      y[i] = (Math.random() - 0.5) * HEIGHT_RANGE;
      tilt[i] = rand(-0.6, 0.6);
      spin[i] = rand(-0.03, 0.03);

      // initial placement
      const x = Math.cos(angle[i]) * radius[i];
      const z = Math.sin(angle[i]) * radius[i];

      dummy.position.set(x, y[i], z);
      dummy.rotation.set(0, angle[i] + Math.PI, tilt[i]);
      dummy.updateMatrix();
      mesh.setMatrixAt(i, dummy.matrix);
    }

    mesh.instanceMatrix.needsUpdate = true;
    scene.add(mesh);

    instancedGroups.push({ mesh, angle, speed, radius, y, tilt, spin });
  }

  /* ===========================
     AUDIO BEAT SYNC (music.mp3)
     =========================== */
  const beatPill = document.getElementById("beatPill");
  const playBtn = document.getElementById("playBtn");
  const pauseBtn = document.getElementById("pauseBtn");

  let audioCtx, analyser, dataArray, audioEl, srcNode;
  let beat = 0; // 0..1

  function setupAudio() {
    if (audioCtx) return;

    audioEl = new Audio("music.mp3"); // taruh music.mp3 di folder yang sama
    audioEl.loop = true;
    audioEl.crossOrigin = "anonymous";

    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 1024;
    analyser.smoothingTimeConstant = 0.82;
    dataArray = new Uint8Array(analyser.frequencyBinCount);

    srcNode = audioCtx.createMediaElementSource(audioEl);
    srcNode.connect(analyser);
    analyser.connect(audioCtx.destination);
  }

  function computeBeat() {
    if (!analyser) { beat = 0; return; }

    analyser.getByteFrequencyData(dataArray);

    // average energy in low-mid band (kick-ish)
    let sum = 0;
    const start = 2;
    const end = Math.floor(dataArray.length * 0.22);
    for (let i = start; i < end; i++) sum += dataArray[i];
    const avg = sum / (end - start) / 255; // 0..1

    // soft clamp + smoothing
    beat = Math.max(0, Math.min(1, avg * 1.6));
    beatPill.textContent = `Beat: ${beat.toFixed(2)}`;
  }

  playBtn.onclick = async () => {
    try {
      setupAudio();
      if (audioCtx.state !== "running") await audioCtx.resume();
      await audioEl.play();
    } catch (e) {
      alert("Taruh file music.mp3 di folder yang sama ya (planet-vvip/music.mp3).");
    }
  };

  pauseBtn.onclick = () => {
    if (audioEl) audioEl.pause();
  };

  /* ===========================
     EXTRA FX: subtle camera drift + nebula rotation
     =========================== */
  let t0 = performance.now();

  function animate() {
    requestAnimationFrame(animate);

    const t = performance.now();
    const dt = Math.min(0.05, (t - t0) / 1000);
    t0 = t;

    computeBeat();

    // Beat affects:
    // - bloom strength
    // - planet emissive intensity
    // - orbit speed multiplier
    const beatBoost = 1 + beat * 1.55;
    bloomPass.strength = bloomStrength * beatBoost;
    bloomPass.radius = bloomRadius + beat * 0.15;
    bloomPass.threshold = bloomThreshold;

    planetMat.emissiveIntensity = 0.22 + beat * 0.65;
    glowMat.opacity = 0.10 + beat * 0.22;

    // Planet rotation
    planet.rotation.y += 0.12 * dt;
    glowShell.rotation.y += 0.10 * dt;

    // Nebula slow drift
    nebula.rotation.y += 0.015 * dt;
    nebula.rotation.x += 0.005 * dt;

    // Camera gentle movement (cinematic)
    camera.position.x = Math.sin(t * 0.00025) * 2.0;
    camera.position.y = 6.5 + Math.sin(t * 0.00018) * 1.0;
    camera.lookAt(0, 0, 0);

    // Update all instanced photos
    const speedMul = 1 + beat * 0.9;

    for (const g of instancedGroups) {
      const { mesh, angle, speed, radius, y, tilt, spin } = g;
      const count = angle.length;

      for (let i = 0; i < count; i++) {
        angle[i] += speed[i] * speedMul;

        const x = Math.cos(angle[i]) * radius[i];
        const z = Math.sin(angle[i]) * radius[i];

        // slight ‚Äúbreathing‚Äù wave
        const yy = y[i] + Math.sin(angle[i] * 2.0) * (0.15 + beat * 0.35);

        dummy.position.set(x, yy, z);

        // face planet + slight tilt + tiny spin for chaos
        dummy.rotation.set(0, angle[i] + Math.PI, tilt[i] + spin[i] * Math.sin(t * 0.001));
        dummy.updateMatrix();
        mesh.setMatrixAt(i, dummy.matrix);
      }

      mesh.instanceMatrix.needsUpdate = true;
    }

    composer.render();
  }
  animate();

  /* ===========================
     RESIZE (keep 9:16)
     =========================== */
  function onResize() {
    const { w, h, aspect } = getRenderSize();
    renderer.setSize(w, h);
    composer.setSize(w, h);

    camera.aspect = aspect;
    camera.updateProjectionMatrix();

    // bloom pass resolution update
    bloomPass.setSize(w, h);
  }
  window.addEventListener("resize", onResize);

</script>
</body>
</html>
