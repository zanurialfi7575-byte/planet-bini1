<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,height=device-height,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
  <title>Nebula Meteor Adventure 3D</title>
  <style>
    html,body{margin:0;padding:0;overflow:hidden;background:#000;touch-action:none;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
    #ui{
      position:fixed;left:12px;top:12px;z-index:10;
      background:rgba(18,18,26,.62);backdrop-filter:blur(10px);
      border-radius:14px;padding:12px;color:#fff;font-size:12px;line-height:1.25;
      max-width:min(380px,92vw)
    }
    #ui b{font-size:13px}
    #ui .row{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
    #ui button{
      background:#24242e;border:0;color:#fff;border-radius:10px;padding:8px 10px;font-size:12px
    }
    #ui button:active{transform:scale(.98)}
    #hud{
      position:fixed;left:12px;bottom:12px;z-index:10;
      color:#bbb;font-size:12px;opacity:.75;background:rgba(0,0,0,.35);
      padding:8px 10px;border-radius:12px;backdrop-filter:blur(10px)
    }
    #love{
      position:fixed;left:50%;top:62%;
      transform:translate(-50%,-50%);
      z-index:11;color:#fff;font-size:18px;text-align:center;
      padding:14px 16px;border-radius:18px;
      background:rgba(0,0,0,.45);backdrop-filter:blur(10px);
      max-width:min(560px,90vw);
      opacity:0;pointer-events:none;
      transition:opacity .25s ease;
      text-shadow:0 8px 22px rgba(0,0,0,.8);
    }
    #love small{display:block;font-size:12px;color:#ddd;opacity:.85;margin-top:6px}
  </style>
</head>
<body>

<div id="ui">
  <b>üåå Nebula Meteor Adventure (3D, 9:16)</b><br>
  ‚Ä¢ Drag = puter ‚Äúbola meteor‚Äù (KERASA 3D)<br>
  ‚Ä¢ 2 jari = zoom ‚Ä¢ Tap meteor = follow<br>
  ‚Ä¢ Hemat HP: render max <b>20</b> meteor terdekat<br>
  <div class="row">
    <button id="btnPlay">‚ñ∂ Play</button>
    <button id="btnPause">‚è∏ Pause</button>
    <button id="btnAuto">üß≠ Auto Tour: OFF</button>
    <button id="btnShuffle">üé≤ Shuffle</button>
    <button id="btnFS">‚õ∂ Fullscreen</button>
  </div>
</div>

<div id="love"></div>
<div id="hud">Loading‚Ä¶</div>

<audio id="music" src="music.mp3" loop></audio>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

/* ============ CONFIG ============ */
const TOTAL_PHOTO   = 43;      // ganti 55 kalau sudah 55
const MAX_RENDER    = 20;      // render meteor terdekat (anti lag)
const METEOR_COUNT  = 1400;    // jumlah data meteor (bukan mesh semua)
const PHOTO_ASPECT  = 9/16;    // portrait
const BASE_H        = 22;      // tinggi plane foto (world units)
const R_MIN         = 140;
const R_MAX         = 520;
const ORBIT_SPEED   = 0.00045;
const NEBULA_SIZE   = 2400;

/* ============ UI & AUDIO ============ */
const hud = document.getElementById("hud");
const loveBox = document.getElementById("love");
const music = document.getElementById("music");

document.getElementById("btnPlay").onclick = ()=> music.play().catch(()=>{});
document.getElementById("btnPause").onclick = ()=> music.pause();

let autoTour = false;
const btnAuto = document.getElementById("btnAuto");
btnAuto.onclick = ()=> {
  autoTour = !autoTour;
  btnAuto.textContent = `üß≠ Auto Tour: ${autoTour ? "ON" : "OFF"}`;
  if(autoTour) followIndex = -1;
};

document.getElementById("btnFS").onclick = async ()=>{
  try{
    if(!document.fullscreenElement) await document.documentElement.requestFullscreen();
    else await document.exitFullscreen();
  }catch(e){}
};

/* ============ SCENE ============ */
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x000000, 0.00078);

const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:"high-performance" });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 1.6));
renderer.outputColorSpace = THREE.SRGBColorSpace;
document.body.appendChild(renderer.domElement);

const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 9000);
camera.position.set(0, 170, 680);

/* Resize */
addEventListener("resize", ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

/* Lights */
scene.add(new THREE.AmbientLight(0xffffff, 0.58));
const key = new THREE.DirectionalLight(0xffffff, 0.65);
key.position.set(400, 700, 600);
scene.add(key);

/* ============ WORLD GROUP (yang diputer) ============ */
const world = new THREE.Group();
scene.add(world);

/* ============ STARS ============ */
function makeStars(count=3000){
  const g = new THREE.BufferGeometry();
  const pos = new Float32Array(count*3);
  for(let i=0;i<count;i++){
    const r = 2200 + Math.random()*2800;
    const a = Math.random()*Math.PI*2;
    const b = (Math.random()*2-1) * 0.9;
    pos[i*3+0] = Math.cos(a)*r;
    pos[i*3+2] = Math.sin(a)*r;
    pos[i*3+1] = b*r*0.22 + (Math.random()*2-1)*650;
  }
  g.setAttribute("position", new THREE.BufferAttribute(pos,3));
  const m = new THREE.PointsMaterial({ size:2.1, color:0xffffff, transparent:true, opacity:0.75, depthWrite:false });
  return new THREE.Points(g,m);
}
scene.add(makeStars());

/* ============ NEBULA (Sprite from canvas) ============ */
function makeNebula(){
  const c = document.createElement("canvas");
  c.width = 1024; c.height = 1024;
  const x = c.getContext("2d");
  x.clearRect(0,0,c.width,c.height);

  function blob(cx,cy,r, colA, colB){
    const g = x.createRadialGradient(cx,cy, 10, cx,cy,r);
    g.addColorStop(0, colA);
    g.addColorStop(1, colB);
    x.fillStyle = g;
    x.beginPath(); x.arc(cx,cy,r,0,Math.PI*2); x.fill();
  }

  blob(520,520,520, "rgba(170,80,255,0.62)", "rgba(0,0,0,0)");
  blob(460,560,470, "rgba(80,220,255,0.45)", "rgba(0,0,0,0)");
  blob(580,480,420, "rgba(255,120,180,0.35)", "rgba(0,0,0,0)");
  blob(520,520,300, "rgba(255,255,255,0.20)", "rgba(0,0,0,0)");

  const img = x.getImageData(0,0,c.width,c.height);
  for(let i=0;i<img.data.length;i+=4){
    const n = (Math.random()-0.5)*26;
    img.data[i+0]=Math.min(255, img.data[i+0] + n);
    img.data[i+1]=Math.min(255, img.data[i+1] + n);
    img.data[i+2]=Math.min(255, img.data[i+2] + n);
  }
  x.putImageData(img,0,0);

  const tex = new THREE.CanvasTexture(c);
  tex.colorSpace = THREE.SRGBColorSpace;

  const mat = new THREE.SpriteMaterial({
    map: tex,
    transparent:true,
    opacity: 1,
    depthWrite:false,
    blending: THREE.AdditiveBlending
  });

  const spr = new THREE.Sprite(mat);
  spr.scale.set(NEBULA_SIZE, NEBULA_SIZE, 1);
  spr.position.set(0,0,0);
  return spr;
}
const nebula = makeNebula();
world.add(nebula);

/* ============ METEOR DATA (pos 3D) ============ */
function rand3D(){
  // sebaran 3D bukan ring rapi: kayak debris
  const t = Math.random();
  const r = Math.sqrt(t*(R_MAX*R_MAX - R_MIN*R_MIN) + R_MIN*R_MIN);
  const a = Math.random()*Math.PI*2;

  // thickness + warp (biar berserakan)
  const y = (Math.random()*2-1) * 150;
  const warp = (Math.random()*2-1) * 70;

  const x = Math.cos(a)*r + warp;
  const z = Math.sin(a)*r - warp;

  return {x,y,z,r,a};
}

const meteors = [];
for(let i=0;i<METEOR_COUNT;i++){
  const p = rand3D();
  meteors.push({
    photoId: 1 + (i % TOTAL_PHOTO),
    x:p.x, y:p.y, z:p.z,
    r:p.r,
    ang:p.a,
    speed: (0.65 + Math.random()*1.1),
    // penting buat ‚Äú3D kerasa‚Äù: tiap meteor punya orientasi beda
    rx: (Math.random()*2-1) * 0.9,
    ry: (Math.random()*2-1) * Math.PI,
    rz: (Math.random()*2-1) * 0.6,
    spin: (Math.random()*2-1) * 0.02
  });
}

/* ============ LOAD TEXTURES ============ */
const loader = new THREE.TextureLoader();
const photoTex = new Array(TOTAL_PHOTO+1);
let loaded = 0;

for(let i=1;i<=TOTAL_PHOTO;i++){
  loader.load(`fotos/${i}.jpg`, (t)=>{
    t.colorSpace = THREE.SRGBColorSpace;
    t.anisotropy = 2;
    photoTex[i]=t;
    loaded++;
  });
}

/* ============ POOL 20 RECTANGLE (9:16) ============ */
const geom = new THREE.PlaneGeometry(BASE_H*PHOTO_ASPECT, BASE_H, 1, 1);
const glowGeom = new THREE.PlaneGeometry(BASE_H*PHOTO_ASPECT*1.22, BASE_H*1.22, 1, 1);

function makeMat(tex){
  return new THREE.MeshBasicMaterial({
    map: tex,
    transparent:true,
    opacity:1,
    side:THREE.DoubleSide,
    depthWrite:false
  });
}

const pool = [];
const poolGlow = [];

for(let i=0;i<MAX_RENDER;i++){
  const m = new THREE.Mesh(geom, makeMat(photoTex[1] || null));
  m.visible = false;
  world.add(m);
  pool.push(m);

  const gm = new THREE.MeshBasicMaterial({
    color:0xffffff,
    transparent:true,
    opacity:0.18,
    blending:THREE.AdditiveBlending,
    depthWrite:false
  });
  const g = new THREE.Mesh(glowGeom, gm);
  g.visible = false;
  world.add(g);
  poolGlow.push(g);
}

/* ============ CONTROL (putar WORLD, bukan billboard) ============ */
let yaw = 0.35, pitch = 0.12;
let dist = 720, targetDist = 720;

let dragging=false, lastX=0, lastY=0;
const dom = renderer.domElement;

dom.addEventListener("pointerdown",(e)=>{
  dragging=true; lastX=e.clientX; lastY=e.clientY;
});
dom.addEventListener("pointermove",(e)=>{
  if(!dragging) return;
  const dx = e.clientX-lastX;
  const dy = e.clientY-lastY;
  yaw   -= dx*0.0042;
  pitch -= dy*0.0036;
  pitch = Math.max(-0.95, Math.min(0.95, pitch));
  lastX=e.clientX; lastY=e.clientY;
  followIndex = -1;
});
dom.addEventListener("pointerup",()=> dragging=false);
dom.addEventListener("pointercancel",()=> dragging=false);

// pinch zoom
let lastPinch=null;
dom.addEventListener("touchmove",(e)=>{
  if(e.touches.length!==2) return;
  e.preventDefault();
  const dx = e.touches[0].clientX - e.touches[1].clientX;
  const dy = e.touches[0].clientY - e.touches[1].clientY;
  const d = Math.hypot(dx,dy);
  if(lastPinch){
    const ratio = d/lastPinch;
    targetDist = THREE.MathUtils.clamp(targetDist/ratio, 220, 1400);
  }
  lastPinch = d;
},{passive:false});
dom.addEventListener("touchend",()=> lastPinch=null);

// wheel
dom.addEventListener("wheel",(e)=>{
  e.preventDefault();
  targetDist = THREE.MathUtils.clamp(targetDist + e.deltaY*0.35, 220, 1400);
},{passive:false});

/* ============ RAYCAST TAP -> FOLLOW ============ */
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
let followIndex = -1;

function pickTap(x,y){
  const rect = dom.getBoundingClientRect();
  mouse.x = ((x-rect.left)/rect.width)*2 - 1;
  mouse.y = -(((y-rect.top)/rect.height)*2 - 1);
  raycaster.setFromCamera(mouse, camera);
  const hits = raycaster.intersectObjects(pool, true);
  if(hits.length){
    const obj = hits[0].object;
    const pi = pool.indexOf(obj);
    if(pi>=0 && pool[pi].userData.dataIndex>=0){
      followIndex = pool[pi].userData.dataIndex;
      autoTour = false;
      btnAuto.textContent = "üß≠ Auto Tour: OFF";
      targetDist = Math.max(240, targetDist*0.82);
    }
  }
}

let tapStart=null;
dom.addEventListener("pointerdown",(e)=>{
  tapStart = {x:e.clientX,y:e.clientY,t:performance.now()};
});
dom.addEventListener("pointerup",(e)=>{
  if(!tapStart) return;
  const moved = Math.hypot(e.clientX-tapStart.x, e.clientY-tapStart.y);
  const dt = performance.now()-tapStart.t;
  if(moved<10 && dt<350) pickTap(e.clientX,e.clientY);
  tapStart=null;
});

/* ============ LOVE LINES ============ */
const loveLines = new Map([
  [1, "Aku nggak butuh semesta‚Ä¶ aku cuma butuh kamu. üåå‚ù§Ô∏è"],
  [2, "Kalau kamu capek, sini‚Äîaku peluk dari jauh. ü§ç"],
  [3, "Di antara jutaan bintang, kamu paling terang buat aku. ‚ú®"],
  [7, "Aku sayang kamu‚Ä¶ lebih dari kata-kata bisa jelasin. üòö"],
  [13,"Kamu rumah paling tenang yang pernah aku temuin. üè°"],
]);

/* Shuffle */
document.getElementById("btnShuffle").onclick = ()=>{
  for(const m of meteors){
    const p = rand3D();
    m.x=p.x; m.y=p.y; m.z=p.z; m.r=p.r; m.ang=p.a;
  }
  followIndex=-1;
};

/* ============ UPDATE CAMERA & WORLD ============ */
const clock = new THREE.Clock();

function updateCameraAndWorld(){
  dist = THREE.MathUtils.lerp(dist, targetDist, 0.10);

  // kamera selalu menghadap pusat
  camera.position.set(0, 0, dist);
  camera.lookAt(0,0,0);

  // ini kunci ‚ÄúKERASA 3D‚Äù: yang diputer adalah WORLD
  world.rotation.y = yaw;
  world.rotation.x = pitch;

  // auto tour: puter pelan
  if(autoTour){
    yaw += 0.001;
    pitch = THREE.MathUtils.lerp(pitch, Math.sin(clock.elapsedTime*0.35)*0.18, 0.02);
    targetDist = THREE.MathUtils.lerp(targetDist, 700 + Math.sin(clock.elapsedTime*0.5)*50, 0.02);
  }

  // follow: ‚Äúpetualangan‚Äù ngikutin meteor yang dipilih
  if(followIndex>=0){
    const m = meteors[followIndex];
    // arahkan world rotation sedikit ke arah meteor (biar meteor ke tengah layar)
    const v = new THREE.Vector3(m.x,m.y,m.z).normalize();
    const ty = Math.atan2(v.x, v.z);
    const tx = Math.asin(THREE.MathUtils.clamp(v.y, -1, 1));
    yaw = THREE.MathUtils.lerp(yaw, ty, 0.04);
    pitch = THREE.MathUtils.lerp(pitch, -tx, 0.04);
    targetDist = THREE.MathUtils.lerp(targetDist, 320, 0.02);
  }

  // nebula selalu menghadap kamera (wajar), tapi dunia tetap 3D
  nebula.quaternion.copy(camera.quaternion);
}

/* ============ ORBIT METEOR ============ */
function updateMeteors(dt){
  for(const m of meteors){
    m.ang += ORBIT_SPEED * m.speed * (dt*60);
    const rr = m.r + Math.sin(m.ang*2.5 + m.rx)*24;
    m.x = Math.cos(m.ang)*rr + Math.sin(m.ang*3.1)*22;
    m.z = Math.sin(m.ang)*rr + Math.cos(m.ang*2.7)*18;
    m.y = m.y*0.999 + Math.sin(m.ang*2.0 + m.ry)*0.25;
    m.ry += m.spin * (dt*60);
  }
}

/* ============ RENDER 20 TERDEKAT ============ */
function renderNearest20(){
  const camPos = new THREE.Vector3();
  camera.getWorldPosition(camPos);

  // karena world diputer, distance dihitung di world space setelah rotasi:
  // trik: pakai posisi meteor lalu transform dengan world.matrixWorld
  world.updateMatrixWorld(true);

  const arr = [];
  const temp = new THREE.Vector3();

  for(let i=0;i<meteors.length;i++){
    const m = meteors[i];
    temp.set(m.x,m.y,m.z).applyMatrix4(world.matrixWorld);
    const d2 = temp.distanceToSquared(camPos);
    arr.push([d2,i,temp.x,temp.y,temp.z]);
  }
  arr.sort((a,b)=>a[0]-b[0]);

  const nearest = arr.slice(0, MAX_RENDER);

  for(let p=0;p<MAX_RENDER;p++){
    const mesh = pool[p];
    const glow = poolGlow[p];

    const item = nearest[p];
    if(!item){
      mesh.visible=false; glow.visible=false; continue;
    }

    const dataIndex = item[1];
    const wx = item[2], wy = item[3], wz = item[4];
    const m = meteors[dataIndex];
    mesh.userData.dataIndex = dataIndex;

    const tex = photoTex[m.photoId];
    if(tex && mesh.material.map !== tex){
      mesh.material.map = tex;
      mesh.material.needsUpdate = true;
    }

    // posisi sudah world space -> taruh langsung di scene (bukan di world)
    // supaya raycast & distance konsisten
    // kita pindahkan mesh ke scene root (sekali) dengan cara: detach kalau perlu
    if(mesh.parent !== scene) scene.add(mesh);
    if(glow.parent !== scene) scene.add(glow);

    mesh.position.set(wx,wy,wz);

    // INI KUNCI 3D: meteor punya rotasi sendiri, bukan ngadep kamera terus
    mesh.rotation.set(m.rx, m.ry, m.rz);

    // scale (dekat besar)
    const distToCam = Math.sqrt(item[0]);
    const scale = THREE.MathUtils.clamp(1.35 - (distToCam/860), 0.25, 1.10);
    mesh.scale.setScalar(scale);

    // fade jauh
    const alpha = THREE.MathUtils.clamp(1.0 - (distToCam/1150), 0.06, 1.0);
    mesh.material.opacity = alpha;

    mesh.visible = true;

    // glow
    glow.position.copy(mesh.position);
    glow.rotation.copy(mesh.rotation);
    glow.scale.setScalar(scale);
    glow.material.opacity = 0.20 * alpha;
    glow.visible = true;
  }

  // romantic text kalau dekat foto tertentu
  const closest = nearest[0];
  if(closest){
    const m = meteors[closest[1]];
    const line = loveLines.get(m.photoId);
    const camDist = Math.sqrt(closest[0]);
    if(line && camDist < 360){
      loveBox.innerHTML = `${line}<small>(${m.photoId}.jpg)</small>`;
      loveBox.style.opacity = 1;
    }else{
      loveBox.style.opacity = 0;
    }
  }else{
    loveBox.style.opacity = 0;
  }
}

/* ============ LOOP ============ */
function animate(){
  requestAnimationFrame(animate);

  const dt = clock.getDelta();
  updateCameraAndWorld();
  updateMeteors(dt);
  renderNearest20();

  hud.textContent = `Loaded ${loaded}/${TOTAL_PHOTO} ‚Ä¢ Render 20/${METEOR_COUNT} ‚Ä¢ Zoom ${dist.toFixed(0)} ‚Ä¢ Follow ${followIndex>=0 ? meteors[followIndex].photoId+".jpg" : "-"}`;

  renderer.render(scene, camera);
}
animate();
</script>
</body>
</html>
