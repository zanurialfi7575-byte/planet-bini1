<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Planet Bini ‚Äî Meteor Adventure (9:16)</title>
  <style>
    html,body{margin:0;height:100%;background:#000;overflow:hidden}
    #stage{
      position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);
      width:min(100vw, calc(100vh * 9/16));
      height:min(100vh, calc(100vw * 16/9));
      background:#000;overflow:hidden;
    }
    canvas{display:block;width:100%;height:100%}

    #ui{
      position:absolute;left:12px;top:12px;z-index:5;
      color:rgba(255,255,255,.92);
      background:rgba(0,0,0,.45);
      border:1px solid rgba(255,255,255,.12);
      border-radius:14px;
      padding:10px 12px;
      backdrop-filter: blur(12px);
      font-family: ui-monospace, Menlo, Consolas, monospace;
      max-width: 340px;
    }
    #ui .title{font-weight:800;font-size:12px;margin-bottom:6px}
    #ui .mut{font-size:11px;opacity:.78;line-height:1.35}
    #ui .row{display:flex;gap:8px;margin-top:8px}
    #ui button{
      flex:1;cursor:pointer;border-radius:12px;padding:10px 10px;
      border:1px solid rgba(255,255,255,.16);
      background:rgba(255,255,255,.06);
      color:#fff;font-size:12px;
    }
    #ui button:hover{background:rgba(255,255,255,.10)}
    #beat{
      display:inline-block;margin-top:6px;
      padding:4px 8px;border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.06);
      font-size:11px;opacity:.9;
    }
    #tip{
      position:absolute;left:50%;bottom:14px;transform:translateX(-50%);
      font-size:11px;color:rgba(255,255,255,.55);
      background:rgba(0,0,0,.25);
      border:1px solid rgba(255,255,255,.10);
      border-radius:999px;padding:6px 10px;
      backdrop-filter: blur(10px);
      pointer-events:none;
      z-index:5;
    }
  </style>
</head>
<body>
  <div id="stage">
    <canvas id="c"></canvas>

    <div id="ui">
      <div class="title">‚òÑÔ∏è Meteor Photo Adventure (9:16)</div>
      <div class="mut">
        - foto jadi meteor berserakan ngorbit planet<br>
        - kamera zoom petualangan (Auto Tour)<br>
        - beat sync ringan (aman HP)<br>
        - musik butuh klik (aturan browser)
      </div>
      <div class="row">
        <button id="play">‚ñ∂ Play</button>
        <button id="pause">‚è∏ Pause</button>
      </div>
      <div class="row">
        <button id="tour">üß≠ Auto Tour: ON</button>
        <button id="shuffle">üé≤ Shuffle</button>
      </div>
      <div id="beat">Beat: 0.00</div>
    </div>

    <div id="tip">Tip: double tap untuk fullscreen ‚Ä¢ drag untuk geser ‚Ä¢ pinch untuk zoom</div>

    <audio id="music" src="music.mp3" loop preload="auto"></audio>
  </div>

<script>
(() => {
  // =======================
  // SETTINGS
  // =======================
  const TEX_COUNT = 43;      // fotos/1.jpg .. fotos/43.jpg
  const METEOR_COUNT = 650;  // naikkan 1200 kalau HP kuat
  const PLANET_R = 150;      // radius planet (unit dunia)
  const FIELD_R = 1100;      // sebaran bintang/nebula
  const DPR = Math.min(2, window.devicePixelRatio || 1);

  // Kamera (fake 3D)
  let cam = {
    x: 0, y: 40, z: 900,     // posisi kamera
    targetX: 0, targetY: 0, targetZ: 0,
    fov: 650,               // makin kecil makin zoom
  };

  // Auto Tour
  let autoTour = true;

  // =======================
  // CANVAS SETUP
  // =======================
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha:false });
  const stage = document.getElementById('stage');

  function resize(){
    const w = stage.clientWidth;
    const h = stage.clientHeight;
    canvas.width  = Math.floor(w * DPR);
    canvas.height = Math.floor(h * DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  addEventListener('resize', resize, {passive:true});
  resize();

  // =======================
  // LOAD IMAGES
  // =======================
  const textures = [];
  let loaded = 0;

  function loadImg(src){
    return new Promise((resolve) => {
      const img = new Image();
      img.loading = 'eager';
      img.onload = () => resolve(img);
      img.onerror = () => resolve(null);
      img.src = src;
    });
  }

  (async ()=>{
    for(let i=1;i<=TEX_COUNT;i++){
      const img = await loadImg(`fotos/${i}.jpg`);
      if(img) textures.push(img);
      loaded++;
    }
    if(!textures.length){
      alert("Gagal load fotos/1.jpg dst. Cek nama file & folder.");
    }
  })();

  // =======================
  // STARFIELD (pre-gen)
  // =======================
  const stars = [];
  for(let i=0;i<900;i++){
    stars.push({
      x:(Math.random()-0.5)*FIELD_R*2,
      y:(Math.random()-0.5)*FIELD_R*2,
      z:(Math.random()-0.5)*FIELD_R*2,
      a: Math.random()*0.9 + 0.1
    });
  }

  // =======================
  // METEORS (photos in orbit)
  // =======================
  function rand(a,b){ return a + Math.random()*(b-a); }

  function makeMeteors(){
    const arr = [];
    for(let i=0;i<METEOR_COUNT;i++){
      // orbit parameters
      const radius = rand(PLANET_R*1.2, PLANET_R*4.2);  // jarak dari planet
      const height = rand(-PLANET_R*1.6, PLANET_R*1.6); // naik turun
      const angle  = rand(0, Math.PI*2);
      const tilt   = rand(-0.9, 0.9);                   // kemiringan orbit
      const speed  = rand(0.002, 0.008);                // kecepatan orbit
      const spin   = rand(-0.03, 0.03);                 // putar sendiri
      const size   = rand(18, 48);                      // ukuran meteor (px di layar nanti)
      const texIdx = i % Math.max(1, textures.length);

      // bentuk meteor: foto lingkaran + glow (kita render)
      arr.push({
        radius, height, angle, tilt, speed, spin, size,
        texIdx,
        seed: Math.random()*9999
      });
    }
    return arr;
  }

  let meteors = makeMeteors();

  // =======================
  // AUDIO + BEAT
  // =======================
  const music = document.getElementById('music');
  const playBtn = document.getElementById('play');
  const pauseBtn = document.getElementById('pause');
  const beatEl = document.getElementById('beat');
  const tourBtn = document.getElementById('tour');
  const shuffleBtn = document.getElementById('shuffle');

  let audioCtx, analyser, dataArray;
  let beat = 0;

  function setupAudio(){
    if(audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 1024;
    analyser.smoothingTimeConstant = 0.82;
    dataArray = new Uint8Array(analyser.frequencyBinCount);

    const src = audioCtx.createMediaElementSource(music);
    src.connect(analyser);
    analyser.connect(audioCtx.destination);
  }

  playBtn.onclick = async ()=>{
    try{
      setupAudio();
      if(audioCtx.state !== 'running') await audioCtx.resume();
      await music.play();
    }catch(e){
      alert("Gagal play. Pastikan music.mp3 ada sejajar index.html");
    }
  };
  pauseBtn.onclick = ()=> music.pause();

  function calcBeat(){
    if(!analyser){ beat = 0; return; }
    analyser.getByteFrequencyData(dataArray);
    let sum = 0;
    const start = 2;
    const end = Math.floor(dataArray.length * 0.22);
    for(let i=start;i<end;i++) sum += dataArray[i];
    const avg = sum / (end-start) / 255;
    beat = Math.max(0, Math.min(1, avg * 1.7));
    beatEl.textContent = `Beat: ${beat.toFixed(2)}`;
  }

  // =======================
  // SIMPLE 3D PROJECT
  // =======================
  function project(px,py,pz){
    // transform into camera space (look at target)
    const tx = cam.targetX, ty = cam.targetY, tz = cam.targetZ;

    // direction (camera -> target)
    let dx = tx - cam.x, dy = ty - cam.y, dz = tz - cam.z;
    const dl = Math.hypot(dx,dy,dz) || 1;
    dx/=dl; dy/=dl; dz/=dl;

    // build a very simple basis (not perfect, but fine for fake 3D)
    // up vector
    const upx=0, upy=1, upz=0;

    // right = dir x up
    let rx = dy*upz - dz*upy;
    let ry = dz*upx - dx*upz;
    let rz = dx*upy - dy*upx;
    const rl = Math.hypot(rx,ry,rz) || 1;
    rx/=rl; ry/=rl; rz/=rl;

    // real up = right x dir
    let ux = ry*dz - rz*dy;
    let uy = rz*dx - rx*dz;
    let uz = rx*dy - ry*dx;

    // point relative to camera
    const x = px - cam.x, y = py - cam.y, z = pz - cam.z;

    // camera space coords
    const cx = x*rx + y*ry + z*rz;
    const cy = x*ux + y*uy + z*uz;
    const cz = x*dx + y*dy + z*dz;

    // perspective
    const f = cam.fov / (cam.fov + cz);
    const sx = (canvas.width / DPR)/2 + cx * f;
    const sy = (canvas.height / DPR)/2 - cy * f;

    return { sx, sy, f, cz };
  }

  // =======================
  // DRAW HELPERS
  // =======================
  function drawNebula(){
    const w = canvas.width / DPR, h = canvas.height / DPR;
    // background
    const g = ctx.createRadialGradient(w*0.35, h*0.35, 10, w*0.5, h*0.55, Math.max(w,h));
    g.addColorStop(0, "rgba(0,180,255,0.12)");
    g.addColorStop(0.35, "rgba(255,0,200,0.10)");
    g.addColorStop(0.7, "rgba(0,255,160,0.08)");
    g.addColorStop(1, "rgba(0,0,0,1)");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);
  }

  function drawStars(){
    ctx.save();
    for(const s of stars){
      const p = project(s.x, s.y, s.z);
      if(p.cz < -cam.fov*0.8) continue;
      const a = Math.max(0, Math.min(1, s.a * p.f));
      const r = 1.2 * p.f;
      ctx.globalAlpha = a * 0.7;
      ctx.fillStyle = "white";
      ctx.beginPath();
      ctx.arc(p.sx, p.sy, r, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
    ctx.globalAlpha = 1;
  }

  function drawPlanet(){
    const w = canvas.width / DPR, h = canvas.height / DPR;
    const p = project(0,0,0);
    const R = PLANET_R * p.f;

    // glow
    const glow = ctx.createRadialGradient(p.sx, p.sy, R*0.2, p.sx, p.sy, R*2.4);
    glow.addColorStop(0, `rgba(180,255,240,${0.28 + beat*0.25})`);
    glow.addColorStop(0.4, `rgba(80,180,255,${0.16 + beat*0.18})`);
    glow.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = glow;
    ctx.beginPath();
    ctx.arc(p.sx, p.sy, R*2.4, 0, Math.PI*2);
    ctx.fill();

    // planet body
    const body = ctx.createRadialGradient(p.sx - R*0.25, p.sy - R*0.25, R*0.2, p.sx, p.sy, R*1.0);
    body.addColorStop(0, "rgba(255,255,255,0.85)");
    body.addColorStop(0.28, "rgba(180,255,240,0.45)");
    body.addColorStop(0.55, "rgba(80,180,255,0.22)");
    body.addColorStop(0.82, "rgba(0,0,0,0.92)");
    body.addColorStop(1, "rgba(0,0,0,1)");
    ctx.fillStyle = body;
    ctx.beginPath();
    ctx.arc(p.sx, p.sy, R, 0, Math.PI*2);
    ctx.fill();

    // vignette
    const vg = ctx.createRadialGradient(w*0.5, h*0.55, Math.min(w,h)*0.1, w*0.5, h*0.55, Math.max(w,h)*0.75);
    vg.addColorStop(0, "rgba(0,0,0,0)");
    vg.addColorStop(1, "rgba(0,0,0,0.85)");
    ctx.fillStyle = vg;
    ctx.fillRect(0,0,w,h);
  }

  function drawMeteor(tex, sx, sy, r, glowA){
    // glow
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    const g = ctx.createRadialGradient(sx, sy, r*0.2, sx, sy, r*1.8);
    g.addColorStop(0, `rgba(255,255,255,${0.28 + glowA})`);
    g.addColorStop(0.4, `rgba(80,180,255,${0.10 + glowA*0.8})`);
    g.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(sx, sy, r*1.8, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    // circle crop image
    ctx.save();
    ctx.beginPath();
    ctx.arc(sx, sy, r, 0, Math.PI*2);
    ctx.closePath();
    ctx.clip();

    ctx.drawImage(tex, sx - r, sy - r, r*2, r*2);
    ctx.restore();

    // border
    ctx.save();
    ctx.strokeStyle = "rgba(255,255,255,0.18)";
    ctx.lineWidth = Math.max(1, r*0.06);
    ctx.beginPath();
    ctx.arc(sx, sy, r, 0, Math.PI*2);
    ctx.stroke();
    ctx.restore();
  }

  // =======================
  // CAMERA CONTROLS (drag + pinch)
  // =======================
  let dragging=false, lastX=0, lastY=0;
  let yaw=0, pitch=0;

  stage.addEventListener('pointerdown', (e)=>{
    dragging=true; lastX=e.clientX; lastY=e.clientY;
    stage.setPointerCapture(e.pointerId);
  });
  stage.addEventListener('pointermove', (e)=>{
    if(!dragging) return;
    const dx=e.clientX-lastX, dy=e.clientY-lastY;
    lastX=e.clientX; lastY=e.clientY;

    yaw += dx * 0.006;
    pitch += dy * 0.004;
    pitch = Math.max(-1.1, Math.min(1.1, pitch));
    autoTour = false;
    tourBtn.textContent = "üß≠ Auto Tour: OFF";
  });
  stage.addEventListener('pointerup', ()=> dragging=false);

  // pinch zoom using wheel (mobile often triggers no wheel; still useful)
  stage.addEventListener('wheel', (e)=>{
    e.preventDefault();
    cam.fov = Math.max(320, Math.min(1100, cam.fov + e.deltaY*0.6));
    autoTour = false;
    tourBtn.textContent = "üß≠ Auto Tour: OFF";
  }, {passive:false});

  // double tap fullscreen
  let lastTap=0;
  stage.addEventListener('touchend', async ()=>{
    const now = Date.now();
    if(now - lastTap < 280){
      try{
        if(!document.fullscreenElement) await document.documentElement.requestFullscreen();
        else await document.exitFullscreen();
      }catch(e){}
    }
    lastTap = now;
  }, {passive:true});

  // =======================
  // UI BUTTONS
  // =======================
  tourBtn.onclick = ()=>{
    autoTour = !autoTour;
    tourBtn.textContent = autoTour ? "üß≠ Auto Tour: ON" : "üß≠ Auto Tour: OFF";
  };
  shuffleBtn.onclick = ()=>{
    meteors = makeMeteors();
  };

  // =======================
  // ANIMATION LOOP
  // =======================
  let t = 0;

  function updateCamera(dt){
    // look at center
    cam.targetX = 0;
    cam.targetY = 0;
    cam.targetZ = 0;

    const beatBoost = 1 + beat*0.8;

    if(autoTour){
      // cinematic travel path
      const a = t*0.18;
      cam.x = Math.cos(a) * (760 - beat*120);
      cam.z = Math.sin(a) * (760 - beat*120);
      cam.y = 120 + Math.sin(a*0.7) * 90;

      // zoom in/out
      cam.fov = 560 - Math.sin(t*0.22)*140 - beat*80;
      cam.fov = Math.max(360, Math.min(950, cam.fov));
    } else {
      // manual orbit by yaw/pitch
      const dist = 820;
      cam.x = Math.cos(yaw) * Math.cos(pitch) * dist;
      cam.z = Math.sin(yaw) * Math.cos(pitch) * dist;
      cam.y = Math.sin(pitch) * dist * 0.55;
    }
  }

  function draw(){
    const w = canvas.width / DPR, h = canvas.height / DPR;

    // clear
    ctx.clearRect(0,0,w,h);

    calcBeat();
    drawNebula();
    drawStars();

    // update time
    const dt = 0.016;
    t += dt;

    updateCamera(dt);

    // update meteors world positions, then sort by depth
    const list = [];
    const speedMul = 1 + beat*0.9;

    for(const m of meteors){
      m.angle += m.speed * speedMul;

      // orbit in 3D around planet (0,0,0)
      const ca = Math.cos(m.angle), sa = Math.sin(m.angle);
      const ct = Math.cos(m.tilt),  st = Math.sin(m.tilt);

      // base circle in XZ
      let x = ca * m.radius;
      let z = sa * m.radius;

      // tilt orbit plane around X axis (simple)
      let y = m.height + (sa * st * (m.radius*0.15));

      // additional wobble
      y += Math.sin(m.angle*2.0 + m.seed) * (6 + beat*10);

      const p = project(x,y,z);
      if(p.cz < -cam.fov*0.9) continue;

      // size with perspective
      const r = (m.size * p.f) * 0.9;
      if(r < 1) continue;

      list.push({ m, p, r });
    }

    // draw far -> near
    list.sort((a,b)=> a.p.cz - b.p.cz);

    // planet behind some meteors? (draw planet first then meteors gives meteors on top, nice)
    drawPlanet();

    // meteors
    if(textures.length){
      for(const it of list){
        const tex = textures[it.m.texIdx % textures.length];
        const glowA = 0.08 + beat*0.22;
        drawMeteor(tex, it.p.sx, it.p.sy, it.r, glowA);
      }
    }

    requestAnimationFrame(draw);
  }

  requestAnimationFrame(draw);
})();
</script>
</body>
  </html>
