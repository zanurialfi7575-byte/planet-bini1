<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Nebula Meteor Adventure (3D, 9:16)</title>
  <style>
    html,body{margin:0;height:100%;background:#000;overflow:hidden;touch-action:none;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
    canvas{display:block;width:100vw;height:100vh}

    /* HUD */
    .hud{
      position:fixed;left:14px;top:14px;z-index:10;
      max-width:min(92vw, 560px);
      background:rgba(10,12,18,.62);
      border:1px solid rgba(255,255,255,.10);
      backdrop-filter: blur(10px);
      border-radius:16px;
      padding:14px 14px 10px;
      color:#e9e9ff;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    .title{font-weight:800;font-size:16px;margin-bottom:6px;letter-spacing:.2px}
    .sub{font-size:12px;opacity:.9;line-height:1.45}
    .row{display:flex;flex-wrap:wrap;gap:10px;margin-top:10px}
    button{
      appearance:none;border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.06);
      color:#fff;border-radius:12px;padding:10px 12px;
      font-weight:700;font-size:13px;
    }
    button:active{transform:scale(.98)}
    button.primary{background:rgba(90,110,255,.22);border-color:rgba(90,110,255,.40)}
    button.danger{background:rgba(255,80,80,.18);border-color:rgba(255,80,80,.35)}
    button.on{outline:2px solid rgba(170,200,255,.65)}
    .stat{margin-top:8px;font-size:12px;opacity:.9;display:flex;gap:10px;flex-wrap:wrap}
    .pill{padding:6px 10px;border-radius:999px;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.10)}

    /* Romantic text */
    .rom{
      position:fixed;left:50%;bottom:92px;transform:translateX(-50%);
      z-index:11;
      background:rgba(10,12,18,.60);
      border:1px solid rgba(255,255,255,.12);
      backdrop-filter: blur(12px);
      border-radius:16px;
      padding:12px 14px;
      color:#fff;
      font-weight:800;
      text-align:center;
      max-width:min(92vw, 720px);
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      opacity:0;
      transition:opacity .25s ease, transform .25s ease;
      pointer-events:none;
      line-height:1.35;
    }
    .rom.show{opacity:1; transform:translateX(-50%) translateY(-6px);}
    .rom small{display:block;margin-top:6px;font-weight:600;opacity:.8}

    .tip{
      position:fixed;left:50%;bottom:24px;transform:translateX(-50%);
      z-index:10;
      background:rgba(0,0,0,.35);
      border:1px solid rgba(255,255,255,.10);
      color:rgba(255,255,255,.85);
      padding:10px 14px;border-radius:999px;
      font-size:12px;backdrop-filter: blur(10px);
    }

    .toast{
      position:fixed;left:50%;top:14px;transform:translateX(-50%);
      z-index:12;
      background:rgba(0,0,0,.55);
      border:1px solid rgba(255,255,255,.12);
      color:#fff;padding:10px 14px;border-radius:12px;
      font-size:12px;opacity:0;transition:opacity .2s ease;
      pointer-events:none;
    }
    .toast.show{opacity:1}
  </style>
</head>

<body>
  <div class="hud">
    <div class="title">üåå Nebula Meteor Adventure (3D, 9:16)</div>
    <div class="sub">
      ‚Ä¢ Drag = puter dunia ‚Ä¢ Pinch = zoom ‚Ä¢ Tap meteor = fokus + follow<br/>
      ‚Ä¢ Hemat HP: hanya <b>20 meteor terdekat</b> yang aktif<br/>
      ‚Ä¢ Foto: <code>fotos/1.jpg</code>.. <code>fotos/43.jpg</code> ‚Ä¢ Musik: <code>music.mp3</code>
    </div>

    <div class="row">
      <button id="btnPlay" class="primary">‚ñ∂ Play</button>
      <button id="btnPause">‚è∏ Pause</button>
      <button id="btnAuto">üß≠ Auto Tour: OFF</button>
      <button id="btnShuffle">üé≤ Shuffle</button>
    </div>

    <div class="row">
      <button id="btnMusic">üéµ Play Music</button>
      <button id="btnFull">‚õ∂ Fullscreen</button>
      <button id="btnRec">üé• Record</button>
      <button id="btnStop" class="danger">‚èπ Stop</button>
    </div>

    <div class="stat">
      <div class="pill" id="stLoaded">Loaded: 0/43</div>
      <div class="pill" id="stActive">Active: 0/20</div>
      <div class="pill" id="stZoom">Zoom: 1.00</div>
      <div class="pill" id="stFollow">Follow: -</div>
    </div>
  </div>

  <div class="rom" id="rom"></div>
  <div class="tip">Tip: double tap = fullscreen ‚Ä¢ drag = geser/rotate ‚Ä¢ pinch = zoom</div>
  <div class="toast" id="toast"></div>

  <audio id="music" src="music.mp3" preload="auto" loop></audio>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

    // =========================
    // CONFIG
    // =========================
    const PHOTO_COUNT = 43;         // fotos/1.jpg..43.jpg
    const METEOR_COUNT = 220;       // total meteor positions (banyak, tapi yang aktif cuma 20)
    const ACTIVE_LIMIT = 20;        // hemat HP
    const TRAIL_POINTS = 14;        // trail panjang
    const WORLD_RADIUS_MIN = 45;
    const WORLD_RADIUS_MAX = 115;

    // foto 9:16 (plane)
    const PHOTO_W = 10;             // ukuran "kartu" di dunia 3D (akan terasa besar/kecil tergantung jarak)
    const PHOTO_H = PHOTO_W * (16/9);

    // zoom
    const MIN_ZOOM = 0.7;   // lebih ‚Äúdeket‚Äù (kamera lebih dekat)
    const MAX_ZOOM = 3.2;   // lebih ‚Äújauh‚Äù

    // =========================
    // UI
    // =========================
    const btnPlay = document.getElementById("btnPlay");
    const btnPause = document.getElementById("btnPause");
    const btnAuto = document.getElementById("btnAuto");
    const btnShuffle = document.getElementById("btnShuffle");
    const btnMusic = document.getElementById("btnMusic");
    const btnFull = document.getElementById("btnFull");
    const btnRec = document.getElementById("btnRec");
    const btnStop = document.getElementById("btnStop");
    const stLoaded = document.getElementById("stLoaded");
    const stActive = document.getElementById("stActive");
    const stZoom = document.getElementById("stZoom");
    const stFollow = document.getElementById("stFollow");
    const rom = document.getElementById("rom");
    const toast = document.getElementById("toast");

    function showToast(msg, ms=1400){
      toast.textContent = msg;
      toast.classList.add("show");
      clearTimeout(showToast._t);
      showToast._t = setTimeout(()=>toast.classList.remove("show"), ms);
    }

    const ROMANTIC = [
      "Aku peduli sama dirimu. ‚ù§Ô∏è",
      "Dimata ku, kamu anak kecil yang jadi penyemangat ku. üè°‚ú®",
      "Aku pasti dibilang buaya karna bikin gini, tapi buaya mana yang mau capek mikir untuk bikin giniüòí",
      "Jangan tinggalin aku.",
      "Aku bakal terus berusaha nyenengin kamu. üòäüíó",
      "Aku bangga sama kamu. üå∑",
    ];

    function showRomantic(text, extra=""){
      rom.innerHTML = `${text}${extra ? `<small>${extra}</small>` : ""}`;
      rom.classList.add("show");
      clearTimeout(showRomantic._t);
      showRomantic._t = setTimeout(()=>rom.classList.remove("show"), 2400);
    }

    // =========================
    // THREE setup
    // =========================
    const renderer = new THREE.WebGLRenderer({
      antialias: true,
      alpha: false,
      powerPreference: "high-performance"
    });
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x03040a, 0.0025);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);

    // Camera orbit parameters
    let yaw = 0.25, pitch = -0.18;
    let zoom = 1.25;
    let targetZoom = zoom;

    // Camera follows an invisible "pivot" in space
    const pivot = new THREE.Vector3(0,0,0);
    const camPos = new THREE.Vector3();

    function updateCamera(){
      const baseDist = 120 / zoom;
      const cp = Math.cos(pitch), sp = Math.sin(pitch);
      const cy = Math.cos(yaw),   sy = Math.sin(yaw);
      camPos.set(
        pivot.x + baseDist * cp * sy,
        pivot.y + baseDist * sp,
        pivot.z + baseDist * cp * cy
      );
      camera.position.copy(camPos);
      camera.lookAt(pivot);
      camera.updateMatrixWorld();
      stZoom.textContent = `Zoom: ${zoom.toFixed(2)}`;
    }

    // =========================
    // Lights (soft)
    // =========================
    const amb = new THREE.AmbientLight(0xffffff, 0.65);
    scene.add(amb);

    const dir = new THREE.DirectionalLight(0xcfe1ff, 0.85);
    dir.position.set(1.2, 1.6, 1.0);
    scene.add(dir);

    // =========================
    // Nebula background (procedural)
    // =========================
    // kita bikin "nebula sphere" besar + shader sederhana (ringan)
    const nebulaGeo = new THREE.SphereGeometry(900, 48, 32);
    const nebulaMat = new THREE.ShaderMaterial({
      side: THREE.BackSide,
      transparent: false,
      uniforms: {
        uTime: { value: 0 },
        uA: { value: new THREE.Color("#1a0b2e") },
        uB: { value: new THREE.Color("#0b1a3a") },
        uC: { value: new THREE.Color("#3b0b34") },
      },
      vertexShader: `
        varying vec3 vPos;
        void main(){
          vPos = position;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
        }
      `,
      fragmentShader: `
        precision highp float;
        varying vec3 vPos;
        uniform float uTime;
        uniform vec3 uA;
        uniform vec3 uB;
        uniform vec3 uC;

        // cheap noise-ish
        float hash(vec3 p){
          p = fract(p*0.3183099 + vec3(0.1,0.2,0.3));
          p *= 17.0;
          return fract(p.x*p.y*p.z*(p.x+p.y+p.z));
        }
        float noise(vec3 p){
          vec3 i = floor(p);
          vec3 f = fract(p);
          f = f*f*(3.0-2.0*f);
          float n000 = hash(i+vec3(0,0,0));
          float n100 = hash(i+vec3(1,0,0));
          float n010 = hash(i+vec3(0,1,0));
          float n110 = hash(i+vec3(1,1,0));
          float n001 = hash(i+vec3(0,0,1));
          float n101 = hash(i+vec3(1,0,1));
          float n011 = hash(i+vec3(0,1,1));
          float n111 = hash(i+vec3(1,1,1));
          float nx00 = mix(n000,n100,f.x);
          float nx10 = mix(n010,n110,f.x);
          float nx01 = mix(n001,n101,f.x);
          float nx11 = mix(n011,n111,f.x);
          float nxy0 = mix(nx00,nx10,f.y);
          float nxy1 = mix(nx01,nx11,f.y);
          return mix(nxy0,nxy1,f.z);
        }
        float fbm(vec3 p){
          float v=0.0;
          float a=0.55;
          for(int i=0;i<5;i++){
            v += a*noise(p);
            p *= 2.02;
            a *= 0.52;
          }
          return v;
        }

        void main(){
          vec3 p = normalize(vPos);
          float t = uTime*0.03;
          float n = fbm(p*3.0 + vec3(t, -t*0.7, t*0.45));
          float n2 = fbm(p*6.0 + vec3(-t*0.8, t*0.5, -t*0.2));
          float v = smoothstep(0.15, 0.92, n*0.75 + n2*0.45);

          // color blend
          vec3 col = mix(uA, uB, clamp(p.y*0.55+0.5,0.0,1.0));
          col = mix(col, uC, v);

          // stars speckle
          float s = pow(noise(p*120.0), 18.0);
          col += vec3(0.9,0.9,1.0) * s * 1.2;

          // vignette
          float edge = smoothstep(0.0, 1.0, 1.0 - abs(p.y)*0.85);
          col *= 0.75 + 0.35*edge;

          gl_FragColor = vec4(col, 1.0);
        }
      `
    });
    const nebula = new THREE.Mesh(nebulaGeo, nebulaMat);
    scene.add(nebula);

    // =========================
    // Meteor system (3D scattered orbit)
    // =========================
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2(0,0);

    // Rounded texture helper (biar foto 9:16 lebih enak, sedikit rounded)
    async function loadRoundedTexture(url, radius=42){
      // load image to canvas and apply rounded mask
      const img = new Image();
      img.crossOrigin = "anonymous";
      const p = new Promise((res, rej)=>{
        img.onload = ()=>res();
        img.onerror = (e)=>rej(e);
      });
      img.src = url;
      await p;

      const w = img.naturalWidth || img.width;
      const h = img.naturalHeight || img.height;

      const c = document.createElement("canvas");
      c.width = w; c.height = h;
      const g = c.getContext("2d");

      // rounded rect path
      const r = Math.min(radius, Math.min(w,h)*0.12);
      g.save();
      g.beginPath();
      const x=0,y=0;
      g.moveTo(x+r,y);
      g.arcTo(x+w,y, x+w,y+h, r);
      g.arcTo(x+w,y+h, x,y+h, r);
      g.arcTo(x,y+h, x,y, r);
      g.arcTo(x,y, x+w,y, r);
      g.closePath();
      g.clip();

      g.drawImage(img,0,0,w,h);
      g.restore();

      // subtle vignette
      const grd = g.createRadialGradient(w*0.5,h*0.45, Math.min(w,h)*0.12, w*0.5,h*0.55, Math.max(w,h)*0.75);
      grd.addColorStop(0,"rgba(0,0,0,0)");
      grd.addColorStop(1,"rgba(0,0,0,0.18)");
      g.fillStyle = grd;
      g.fillRect(0,0,w,h);

      const tex = new THREE.CanvasTexture(c);
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.anisotropy = 4;
      tex.needsUpdate = true;
      return tex;
    }

    // LRU cache textures (max 20 active) ‚Äî hemat RAM
    const texCache = new Map(); // key: photoIndex -> {tex, last}
    let loadedCount = 0;

    async function getPhotoTexture(photoIndex){
      const key = photoIndex;
      if (texCache.has(key)) {
        texCache.get(key).last = performance.now();
        return texCache.get(key).tex;
      }
      // evict if full
      if (texCache.size >= ACTIVE_LIMIT){
        let oldestKey = null;
        let oldest = Infinity;
        for (const [k,v] of texCache.entries()){
          if (v.last < oldest){ oldest = v.last; oldestKey = k; }
        }
        if (oldestKey !== null){
          const v = texCache.get(oldestKey);
          v.tex.dispose();
          texCache.delete(oldestKey);
        }
      }

      const url = `fotos/${photoIndex}.jpg`;
      const tex = await loadRoundedTexture(url, 52);
      loadedCount++;
      stLoaded.textContent = `Loaded: ${loadedCount}/${PHOTO_COUNT}`;
      texCache.set(key, { tex, last: performance.now() });
      return tex;
    }

    // Generate scattered points with minimum spacing (simple rejection)
    function randomOnSphere(){
      const u = Math.random()*2-1;
      const t = Math.random()*Math.PI*2;
      const r = Math.sqrt(1-u*u);
      return new THREE.Vector3(r*Math.cos(t), u, r*Math.sin(t));
    }

    function generateMeteorPositions(count, minDist=10){
      const pts = [];
      let tries = 0;
      while (pts.length < count && tries < 50000){
        tries++;
        const dir = randomOnSphere();
        const rad = THREE.MathUtils.lerp(WORLD_RADIUS_MIN, WORLD_RADIUS_MAX, Math.pow(Math.random(), 0.55));
        const p = dir.multiplyScalar(rad);

        let ok = true;
        for (let i=0;i<pts.length;i++){
          if (p.distanceTo(pts[i]) < minDist){ ok = false; break; }
        }
        if (ok) pts.push(p);
      }
      return pts;
    }

    // Meteor mesh (plane)
    const meteorGroup = new THREE.Group();
    scene.add(meteorGroup);

    const cardGeo = new THREE.PlaneGeometry(PHOTO_W, PHOTO_H, 1, 1);

    function makeCardMaterial(){
      return new THREE.MeshStandardMaterial({
        color: 0xffffff,
        roughness: 0.85,
        metalness: 0.05,
        transparent: true,
        opacity: 0.0, // inactive by default
        depthWrite: false
      });
    }

    // Fake glow outline (very cheap): second plane behind
    function makeGlow(){
      const g = new THREE.PlaneGeometry(PHOTO_W*1.08, PHOTO_H*1.08);
      const m = new THREE.MeshBasicMaterial({
        color: 0x93b3ff,
        transparent: true,
        opacity: 0.0,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });
      const glow = new THREE.Mesh(g,m);
      glow.position.z = -0.18;
      return glow;
    }

    // Trail line
    function makeTrail(){
      const pts = Array.from({length:TRAIL_POINTS}, ()=>new THREE.Vector3(0,0,0));
      const geom = new THREE.BufferGeometry().setFromPoints(pts);
      const mat = new THREE.LineBasicMaterial({
        color: 0x9bbcff,
        transparent: true,
        opacity: 0.0,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });
      const line = new THREE.Line(geom, mat);
      line.frustumCulled = false;
      return { line, pts, geom, mat };
    }

    const meteorPos = generateMeteorPositions(METEOR_COUNT, 9.2);
    const meteors = [];

    for (let i=0;i<METEOR_COUNT;i++){
      const mesh = new THREE.Mesh(cardGeo, makeCardMaterial());
      mesh.frustumCulled = false;

      const glow = makeGlow();
      mesh.add(glow);

      const trail = makeTrail();
      meteorGroup.add(trail.line);
      meteorGroup.add(mesh);

      // each meteor uses one of 1..43 photos (repeat)
      const photoIndex = (i % PHOTO_COUNT) + 1;

      // orbit axis & speed
      const axis = randomOnSphere().normalize();
      const speed = THREE.MathUtils.lerp(0.08, 0.28, Math.random()); // slow orbit
      const phase = Math.random()*Math.PI*2;

      meteors.push({
        i,
        mesh,
        glow,
        trail,
        photoIndex,
        axis,
        speed,
        phase,
        base: meteorPos[i].clone(),
        pos: meteorPos[i].clone(),
        active: false,
        texReady: false
      });

      // init trail points at position
      for (let k=0;k<TRAIL_POINTS;k++){
        trail.pts[k].copy(meteorPos[i]);
      }
      trail.geom.setFromPoints(trail.pts);
    }

    // =========================
    // World run state
    // =========================
    let running = true;
    let autoTour = false;
    let follow = null; // meteor object
    let autoTimer = 0;

    // buttons
    btnPlay.onclick = ()=>{ running = true; showToast("Play"); };
    btnPause.onclick = ()=>{ running = false; showToast("Pause"); };
    btnAuto.onclick = ()=>{
      autoTour = !autoTour;
      btnAuto.textContent = `üß≠ Auto Tour: ${autoTour ? "ON" : "OFF"}`;
      btnAuto.classList.toggle("on", autoTour);
      if (autoTour) showToast("Auto Tour ON");
    };
    btnShuffle.onclick = ()=>{
      // shuffle photo assignment only (positions tetap)
      for (let m of meteors){
        m.photoIndex = (Math.floor(Math.random()*PHOTO_COUNT) + 1);
        m.texReady = false;
        m.mesh.material.map = null;
        m.mesh.material.needsUpdate = true;
      }
      loadedCount = 0;
      texCache.forEach(v=>v.tex.dispose());
      texCache.clear();
      stLoaded.textContent = `Loaded: 0/${PHOTO_COUNT}`;
      showToast("Shuffle!");
    };

    const music = document.getElementById("music");
    let musicOn = false;
    btnMusic.onclick = async ()=>{
      try{
        if (!musicOn){
          await music.play();
          musicOn = true;
          btnMusic.textContent = "üéµ Pause Music";
          showToast("Music ON");
        } else {
          music.pause();
          musicOn = false;
          btnMusic.textContent = "üéµ Play Music";
          showToast("Music OFF");
        }
      }catch(e){
        showToast("Browser minta klik lagi buat play musik üôè", 1800);
      }
    };

    btnFull.onclick = async ()=>{
      try{
        if (!document.fullscreenElement){
          await document.documentElement.requestFullscreen();
          showToast("Fullscreen");
        } else {
          await document.exitFullscreen();
        }
      }catch(e){
        showToast("Fullscreen gagal (browser)");
      }
    };

    // =========================
    // Recording (WebM)
    // =========================
    let mediaRecorder = null;
    let recChunks = [];

    btnRec.onclick = ()=>{
      try{
        const stream = renderer.domElement.captureStream(30);
        mediaRecorder = new MediaRecorder(stream, { mimeType: "video/webm;codecs=vp9" });
        recChunks = [];
        mediaRecorder.ondataavailable = e => { if (e.data.size) recChunks.push(e.data); };
        mediaRecorder.onstop = () => {
          const blob = new Blob(recChunks, { type: "video/webm" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = "nebula_meteor_adventure.webm";
          a.click();
          setTimeout(()=>URL.revokeObjectURL(url), 2000);
          showToast("Video tersimpan ‚úÖ");
        };
        mediaRecorder.start();
        showToast("Recording...");
      }catch(e){
        showToast("Record tidak didukung di browser ini", 1800);
      }
    };

    btnStop.onclick = ()=>{
      if (mediaRecorder && mediaRecorder.state !== "inactive"){
        mediaRecorder.stop();
        showToast("Stop");
      }
    };

    // =========================
    // Touch controls (drag rotate + pinch zoom)
    // =========================
    let pointers = new Map();
    let lastTap = 0;

    function clampPitch(p){
      return THREE.MathUtils.clamp(p, -1.25, 1.05);
    }

    renderer.domElement.addEventListener("pointerdown", (e)=>{
      renderer.domElement.setPointerCapture(e.pointerId);
      pointers.set(e.pointerId, {x:e.clientX, y:e.clientY});
    });

    renderer.domElement.addEventListener("pointermove", (e)=>{
      if (!pointers.has(e.pointerId)) return;
      const p = pointers.get(e.pointerId);
      const dx = e.clientX - p.x;
      const dy = e.clientY - p.y;
      p.x = e.clientX; p.y = e.clientY;

      if (pointers.size === 1){
        // rotate
        yaw += dx * 0.0052;
        pitch = clampPitch(pitch + dy * 0.0046);
      } else if (pointers.size === 2){
        // pinch
        const arr = Array.from(pointers.values());
        const a = arr[0], b = arr[1];
        const dist = Math.hypot(a.x-b.x, a.y-b.y);
        if (!renderer._pinchDist) renderer._pinchDist = dist;
        const delta = dist - renderer._pinchDist;
        renderer._pinchDist = dist;
        targetZoom = THREE.MathUtils.clamp(targetZoom + delta * 0.0022, MIN_ZOOM, MAX_ZOOM);
      }
    });

    function clearPinch(){
      renderer._pinchDist = null;
    }

    renderer.domElement.addEventListener("pointerup", (e)=>{
      pointers.delete(e.pointerId);
      if (pointers.size < 2) clearPinch();

      // tap detect (single pointer)
      const now = performance.now();
      const isDoubleTap = (now - lastTap) < 260;
      lastTap = now;

      if (isDoubleTap){
        btnFull.click();
        return;
      }

      // pick meteor on tap (only if it was a short tap)
      // We treat pointerup as tap if movement small
      // (simple: always raycast on pointerup)
      const rect = renderer.domElement.getBoundingClientRect();
      const x = ((e.clientX - rect.left)/rect.width)*2 - 1;
      const y = -(((e.clientY - rect.top)/rect.height)*2 - 1);
      pointer.set(x,y);
      pickMeteor();
    });

    renderer.domElement.addEventListener("pointercancel", (e)=>{
      pointers.delete(e.pointerId);
      if (pointers.size < 2) clearPinch();
    });

    // =========================
    // Pick + Focus/Follow
    // =========================
    function pickMeteor(){
      raycaster.setFromCamera(pointer, camera);
      // Raycast only ACTIVE meteors (20 terdekat)
      const activeMeshes = meteors.filter(m=>m.active).map(m=>m.mesh);
      const hits = raycaster.intersectObjects(activeMeshes, false);
      if (hits.length){
        const hitMesh = hits[0].object;
        const m = meteors.find(mm => mm.mesh === hitMesh);
        if (m){
          follow = m;
          stFollow.textContent = `Follow: fotos/${m.photoIndex}.jpg`;
          focusToMeteor(m, true);
        }
      }
    }

    // smooth focus animation
    let focusAnim = null;
    function focusToMeteor(m, showText){
      const destPivot = m.pos.clone();

      // move pivot near meteor, but keep some offset so meteor can fill screen
      const dirToCam = camera.position.clone().sub(pivot).normalize();
      const offset = dirToCam.multiplyScalar(6.0);
      const finalPivot = destPivot.clone().add(offset);

      const startPivot = pivot.clone();
      const startZoom = targetZoom;
      const endZoom = Math.min(MAX_ZOOM, 2.6);

      focusAnim = {
        t: 0,
        dur: 0.55,
        startPivot,
        endPivot: finalPivot,
        startZoom,
        endZoom,
        meteor: m
      };

      // romantic text
      if (showText){
        const idx = (m.i % ROMANTIC.length);
        showRomantic(ROMANTIC[idx], `(foto ${m.photoIndex}.jpg)`);
      }
    }

    // =========================
    // Active limit (20 nearest)
    // =========================
    async function updateActiveSet(){
      // choose nearest to camera (or pivot) ‚Äî more cinematic = based on camera
      const cam = camera.position;
      const arr = meteors.map(m => ({ m, d: m.pos.distanceTo(cam) }));
      arr.sort((a,b)=>a.d-b.d);
      const active = new Set(arr.slice(0, ACTIVE_LIMIT).map(x=>x.m));

      let actCount = 0;
      for (const m of meteors){
        if (active.has(m)){
          actCount++;
          if (!m.active){
            m.active = true;
            // show glow and trail a bit
            m.mesh.material.opacity = 1.0;
            m.glow.material.opacity = 0.42;
            m.trail.mat.opacity = 0.35;
            // lazy load texture
            if (!m.texReady){
              try{
                const tex = await getPhotoTexture(m.photoIndex);
                m.mesh.material.map = tex;
                m.mesh.material.needsUpdate = true;
                m.texReady = true;
              }catch(e){
                // ignore load error
              }
            }
          }
        } else {
          if (m.active){
            m.active = false;
            m.mesh.material.opacity = 0.0;
            m.glow.material.opacity = 0.0;
            m.trail.mat.opacity = 0.0;
          }
        }
      }
      stActive.textContent = `Active: ${actCount}/${ACTIVE_LIMIT}`;
    }

    // =========================
    // Animation
    // =========================
    const clock = new THREE.Clock();

    function animate(){
      requestAnimationFrame(animate);
      const dt = Math.min(0.033, clock.getDelta());
      const t = clock.elapsedTime;

      // smooth zoom
      zoom = THREE.MathUtils.lerp(zoom, targetZoom, 1 - Math.pow(0.0001, dt));
      updateCamera();

      // update nebula shader
      nebulaMat.uniforms.uTime.value = t;

      // orbit meteors
      if (running){
        for (const m of meteors){
          const ang = (t*m.speed + m.phase);
          const q = new THREE.Quaternion().setFromAxisAngle(m.axis, ang);
          m.pos.copy(m.base).applyQuaternion(q);

          // make them face camera but stay upright (billboard-ish, no spin foto)
          m.mesh.position.copy(m.pos);

          // face camera (billboard)
          m.mesh.quaternion.copy(camera.quaternion);

          // update trail only if active (hemat)
          if (m.active){
            // shift trail points
            const pts = m.trail.pts;
            for (let k=TRAIL_POINTS-1;k>0;k--){
              pts[k].copy(pts[k-1]);
            }
            pts[0].copy(m.pos);

            // write geometry
            m.trail.geom.setFromPoints(pts);

            // trail position line
            // (already in world coords, line geometry is in world space)
          }
        }

        // auto tour
        if (autoTour){
          autoTimer += dt;
          if (autoTimer > 4.2){
            autoTimer = 0;
            // pick a random active meteor
            const act = meteors.filter(mm=>mm.active);
            if (act.length){
              const m = act[Math.floor(Math.random()*act.length)];
              follow = m;
              stFollow.textContent = `Follow: fotos/${m.photoIndex}.jpg`;
              focusToMeteor(m, true);
            }
          }
        }
      }

      // focus animation
      if (focusAnim){
        focusAnim.t += dt;
        const k = Math.min(1, focusAnim.t / focusAnim.dur);
        // smoothstep
        const s = k*k*(3-2*k);
        pivot.lerpVectors(focusAnim.startPivot, focusAnim.endPivot, s);
        targetZoom = THREE.MathUtils.lerp(focusAnim.startZoom, focusAnim.endZoom, s);

        if (k >= 1) focusAnim = null;
      }

      // follow mode: pivot slowly follows selected meteor (kamera ngikutin)
      if (follow && !focusAnim){
        // ease pivot toward meteor, but keep slight offset so camera feels like ‚Äúngikutin‚Äù
        const desired = follow.pos.clone().add(
          camera.position.clone().sub(pivot).normalize().multiplyScalar(6.0)
        );
        pivot.lerp(desired, 1 - Math.pow(0.001, dt));
      }

      // update active set not every frame (hemat)
      animate._acc = (animate._acc || 0) + dt;
      if (animate._acc > 0.22){
        animate._acc = 0;
        updateActiveSet();
      }

      renderer.render(scene, camera);
    }

    // init camera
    updateCamera();
    updateActiveSet();
    animate();

    // =========================
    // Resize
    // =========================
    window.addEventListener("resize", ()=>{
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
    });

    // Start message
    showToast("Siap! Tap meteor untuk fokus + follow");
  </script>
</body>
</html>
