<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Planet Foto Cinematic (9:16)</title>
  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; }
    canvas { display:block; background:#000; }

    .ui{
      position:fixed; left:12px; top:12px; z-index:10;
      font-family: ui-monospace, Menlo, Consolas, monospace;
      color: rgba(255,255,255,.88);
      background: rgba(0,0,0,.40);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 14px;
      padding: 10px 12px;
      backdrop-filter: blur(10px);
      max-width: 340px;
    }
    .ui h3{ margin:0 0 6px; font-size:12px; font-weight:800; letter-spacing:.2px; }
    .ui .mut{ font-size:11px; opacity:.78; line-height:1.35; }
    .ui .row{ display:flex; gap:8px; margin-top:8px; }
    .ui button{
      flex:1; cursor:pointer; border-radius:12px; padding:10px 10px;
      border:1px solid rgba(255,255,255,.16);
      background:rgba(255,255,255,.06);
      color:#fff; font-size:12px;
    }
    .ui button:hover{ background:rgba(255,255,255,.10); }
    .ui .pill{
      display:inline-block; margin-top:6px;
      padding:4px 8px; border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.06);
      font-size:11px; opacity:.9;
    }
  </style>
</head>
<body>

<div class="ui">
  <h3>üåç Planet Foto Cinematic (9:16)</h3>
  <div class="mut">
    - sumber foto: <b>43</b> (repeat jadi ribuan)<br>
    - glow nebula + bloom<br>
    - beat sync: taruh <b>music.mp3</b><br>
    - musik butuh klik (aturan browser)
  </div>
  <div class="row">
    <button id="playBtn">‚ñ∂ Play Music</button>
    <button id="pauseBtn">‚è∏ Pause</button>
  </div>
  <div class="pill" id="beatPill">Beat: 0.00</div>
</div>

<script type="module">
  import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
  import { EffectComposer } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js";
  import { RenderPass } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/RenderPass.js";
  import { UnrealBloomPass } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js";

  /* ===========================
     SETTINGS (EDIT DI SINI)
     =========================== */
  const TEX_COUNT = 43;            // ‚úÖ kamu punya 1.jpg - 43.jpg
  const ASPECT_W = 9, ASPECT_H = 16;

  // Default aman buat HP (naikin kalau device kuat)
  const PHOTO_COUNT = autoPhotoCount();     // ribuan foto orbit
  const USE_PIXEL_RATIO = false;            // false = lebih enteng untuk HP

  // Orbit tuning
  const RADIUS_MIN = 15;
  const RADIUS_MAX = 40;
  const HEIGHT_RANGE = 24;
  const BASE_SPEED_MIN = 0.0014;
  const BASE_SPEED_MAX = 0.0046;

  // Photo size (portrait)
  const PHOTO_W = 1.55;
  const PHOTO_H = 2.20;

  // Planet
  const PLANET_RADIUS = 9.8;

  // Bloom
  const bloomBaseStrength = 1.25;
  const bloomBaseRadius   = 0.55;
  const bloomThreshold    = 0.08;

  function autoPhotoCount(){
    // auto adapt: HP lemah = lebih sedikit, HP kuat = lebih banyak
    // (perkiraan sederhana berbasis deviceMemory + ukuran layar)
    const dm = navigator.deviceMemory || 4; // 0.5/1/2/4/8
    const px = Math.max(screen.width, screen.height);
    if (dm <= 2) return 2500;
    if (dm <= 4) return 3500;
    if (px >= 1200 && dm >= 8) return 8000;
    return 5000;
  }

  /* ===========================
     9:16 render fit
     =========================== */
  function getRenderSize() {
    const winW = innerWidth, winH = innerHeight;
    const targetAspect = ASPECT_W / ASPECT_H;

    let w = winW;
    let h = Math.floor(w / targetAspect);
    if (h > winH) { h = winH; w = Math.floor(h * targetAspect); }
    return { w, h, aspect: targetAspect };
  }

  /* ===========================
     SCENE
     =========================== */
  const scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x000000, 0.016);

  const { w: initW, h: initH, aspect } = getRenderSize();
  const camera = new THREE.PerspectiveCamera(55, aspect, 0.1, 2000);
  camera.position.set(0, 6.2, 56);

  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false, powerPreference: "high-performance" });
  renderer.setSize(initW, initH);
  renderer.setClearColor(0x000000, 1);
  renderer.setPixelRatio(USE_PIXEL_RATIO ? Math.min(2, devicePixelRatio || 1) : 1);
  document.body.appendChild(renderer.domElement);

  // Center the canvas (9:16 fitted)
  renderer.domElement.style.position = "fixed";
  renderer.domElement.style.left = "50%";
  renderer.domElement.style.top = "50%";
  renderer.domElement.style.transform = "translate(-50%, -50%)";

  /* ===========================
     POSTPROCESS: BLOOM
     =========================== */
  const composer = new EffectComposer(renderer);
  composer.addPass(new RenderPass(scene, camera));
  const bloomPass = new UnrealBloomPass(new THREE.Vector2(initW, initH), bloomBaseStrength, bloomBaseRadius, bloomThreshold);
  composer.addPass(bloomPass);

  /* ===========================
     LIGHTING
     =========================== */
  scene.add(new THREE.AmbientLight(0xffffff, 0.32));

  const keyLight = new THREE.DirectionalLight(0x88ccff, 1.15);
  keyLight.position.set(20, 18, 22);
  scene.add(keyLight);

  const rimLight = new THREE.DirectionalLight(0xff66cc, 0.62);
  rimLight.position.set(-26, 8, -20);
  scene.add(rimLight);

  /* ===========================
     NEBULA (particles)
     =========================== */
  function makeNebula(count = 1800) {
    const geo = new THREE.BufferGeometry();
    const positions = new Float32Array(count * 3);
    const colors = new Float32Array(count * 3);

    const A = new THREE.Color(0x2cff9f);
    const B = new THREE.Color(0xbd93f9);
    const C = new THREE.Color(0x66d9ef);

    for (let i = 0; i < count; i++) {
      const r = 210 * Math.pow(Math.random(), 0.35);
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(2 * Math.random() - 1);

      positions[i*3+0] = r * Math.sin(phi) * Math.cos(theta);
      positions[i*3+1] = r * Math.cos(phi);
      positions[i*3+2] = r * Math.sin(phi) * Math.sin(theta);

      const t = Math.random();
      const col = (t < 0.33) ? A.clone().lerp(B, Math.random())
                : (t < 0.66) ? B.clone().lerp(C, Math.random())
                : C.clone().lerp(A, Math.random());

      colors[i*3+0] = col.r;
      colors[i*3+1] = col.g;
      colors[i*3+2] = col.b;
    }

    geo.setAttribute("position", new THREE.BufferAttribute(positions, 3));
    geo.setAttribute("color", new THREE.BufferAttribute(colors, 3));

    const mat = new THREE.PointsMaterial({
      size: 1.25,
      vertexColors: true,
      transparent: true,
      opacity: 0.62,
      depthWrite: false,
      blending: THREE.AdditiveBlending
    });

    const pts = new THREE.Points(geo, mat);
    return pts;
  }

  const nebula = makeNebula(2100);
  scene.add(nebula);

  /* ===========================
     PLANET (glowing)
     =========================== */
  const planetGeo = new THREE.SphereGeometry(PLANET_RADIUS, 96, 96);
  const planetMat = new THREE.MeshStandardMaterial({
    color: 0x0a0a12,
    emissive: 0x2cff9f,
    emissiveIntensity: 0.20,
    roughness: 0.86,
    metalness: 0.14
  });
  const planet = new THREE.Mesh(planetGeo, planetMat);
  scene.add(planet);

  // atmosphere shell
  const glowGeo = new THREE.SphereGeometry(PLANET_RADIUS * 1.06, 96, 96);
  const glowMat = new THREE.MeshBasicMaterial({
    color: 0x66d9ef,
    transparent: true,
    opacity: 0.10,
    blending: THREE.AdditiveBlending,
    depthWrite: false
  });
  const glowShell = new THREE.Mesh(glowGeo, glowMat);
  scene.add(glowShell);

  /* ===========================
     LOAD 43 TEXTURES: fotos/1.jpg ... fotos/43.jpg
     =========================== */
  const loader = new THREE.TextureLoader();
  const textures = [];
  for (let i = 1; i <= TEX_COUNT; i++) {
    const tex = loader.load(`fotos/${i}.jpg`);
    tex.colorSpace = THREE.SRGBColorSpace;
    tex.anisotropy = Math.min(8, renderer.capabilities.getMaxAnisotropy());
    textures.push(tex);
  }

  /* ===========================
     INSTANCED PHOTOS (fast)
     - per texture: one InstancedMesh
     =========================== */
  const basePlane = new THREE.PlaneGeometry(PHOTO_W, PHOTO_H);
  const instancedGroups = [];
  const dummy = new THREE.Object3D();

  const basePerTex = Math.floor(PHOTO_COUNT / TEX_COUNT);
  let remainder = PHOTO_COUNT - basePerTex * TEX_COUNT;

  const rand = (a,b)=>a+Math.random()*(b-a);

  for (let t = 0; t < TEX_COUNT; t++) {
    const count = basePerTex + (remainder-- > 0 ? 1 : 0);

    const mat = new THREE.MeshBasicMaterial({
      map: textures[t],
      transparent: true,
      opacity: 0.95,
      depthWrite: false
    });

    const mesh = new THREE.InstancedMesh(basePlane, mat, count);
    mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    mesh.frustumCulled = false;
    scene.add(mesh);

    const angle = new Float32Array(count);
    const speed = new Float32Array(count);
    const radius = new Float32Array(count);
    const y = new Float32Array(count);
    const tilt = new Float32Array(count);
    const spin = new Float32Array(count);

    for (let i = 0; i < count; i++) {
      angle[i] = Math.random() * Math.PI * 2;
      speed[i] = rand(BASE_SPEED_MIN, BASE_SPEED_MAX);
      radius[i] = rand(RADIUS_MIN, RADIUS_MAX);
      y[i] = (Math.random() - 0.5) * HEIGHT_RANGE;
      tilt[i] = rand(-0.6, 0.6);
      spin[i] = rand(-0.03, 0.03);

      const x = Math.cos(angle[i]) * radius[i];
      const z = Math.sin(angle[i]) * radius[i];

      dummy.position.set(x, y[i], z);
      dummy.rotation.set(0, angle[i] + Math.PI, tilt[i]);
      dummy.updateMatrix();
      mesh.setMatrixAt(i, dummy.matrix);
    }

    mesh.instanceMatrix.needsUpdate = true;
    instancedGroups.push({ mesh, angle, speed, radius, y, tilt, spin });
  }

  /* ===========================
     AUDIO BEAT SYNC (music.mp3)
     =========================== */
  const beatPill = document.getElementById("beatPill");
  const playBtn = document.getElementById("playBtn");
  const pauseBtn = document.getElementById("pauseBtn");

  let audioCtx, analyser, dataArray, audioEl, srcNode;
  let beat = 0;

  function setupAudio() {
    if (audioCtx) return;

    audioEl = new Audio("music.mp3");
    audioEl.loop = true;
    audioEl.crossOrigin = "anonymous";

    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 1024;
    analyser.smoothingTimeConstant = 0.82;
    dataArray = new Uint8Array(analyser.frequencyBinCount);

    srcNode = audioCtx.createMediaElementSource(audioEl);
    srcNode.connect(analyser);
    analyser.connect(audioCtx.destination);
  }

  function computeBeat() {
    if (!analyser) { beat = 0; return; }
    analyser.getByteFrequencyData(dataArray);

    // low-mid energy (kick-ish)
    let sum = 0;
    const start = 2;
    const end = Math.floor(dataArray.length * 0.22);
    for (let i = start; i < end; i++) sum += dataArray[i];
    const avg = sum / (end - start) / 255;

    beat = Math.max(0, Math.min(1, avg * 1.6));
    beatPill.textContent = `Beat: ${beat.toFixed(2)}`;
  }

  playBtn.onclick = async () => {
    try{
      setupAudio();
      if (audioCtx.state !== "running") await audioCtx.resume();
      await audioEl.play();
    }catch(e){
      alert("Pastikan file music.mp3 ada di root repo (sejajar dengan index.html).");
    }
  };
  pauseBtn.onclick = ()=>{ if (audioEl) audioEl.pause(); };

  /* ===========================
     ANIMATE
     =========================== */
  let t0 = performance.now();

  function animate(){
    requestAnimationFrame(animate);

    const t = performance.now();
    const dt = Math.min(0.05, (t - t0) / 1000);
    t0 = t;

    computeBeat();

    // Beat affects bloom + planet glow + orbit speed
    const beatBoost = 1 + beat * 1.55;
    bloomPass.strength = bloomBaseStrength * beatBoost;
    bloomPass.radius   = bloomBaseRadius + beat * 0.15;
    bloomPass.threshold = bloomThreshold;

    planetMat.emissiveIntensity = 0.20 + beat * 0.65;
    glowMat.opacity = 0.09 + beat * 0.22;

    // planet / nebula drift
    planet.rotation.y += 0.12 * dt;
    glowShell.rotation.y += 0.10 * dt;
    nebula.rotation.y += 0.015 * dt;
    nebula.rotation.x += 0.005 * dt;

    // cinematic camera drift
    camera.position.x = Math.sin(t * 0.00025) * 2.0;
    camera.position.y = 6.2 + Math.sin(t * 0.00018) * 1.0;
    camera.lookAt(0, 0, 0);

    const speedMul = 1 + beat * 0.9;

    for (const g of instancedGroups) {
      const { mesh, angle, speed, radius, y, tilt, spin } = g;
      const count = angle.length;

      for (let i = 0; i < count; i++) {
        angle[i] += speed[i] * speedMul;

        const x = Math.cos(angle[i]) * radius[i];
        const z = Math.sin(angle[i]) * radius[i];
        const yy = y[i] + Math.sin(angle[i] * 2.0) * (0.14 + beat * 0.33);

        dummy.position.set(x, yy, z);
        dummy.rotation.set(0, angle[i] + Math.PI, tilt[i] + spin[i] * Math.sin(t * 0.001));
        dummy.updateMatrix();
        mesh.setMatrixAt(i, dummy.matrix);
      }
      mesh.instanceMatrix.needsUpdate = true;
    }

    composer.render();
  }
  animate();

  /* ===========================
     RESIZE keep 9:16 fit
     =========================== */
  function onResize(){
    const { w, h, aspect } = getRenderSize();
    renderer.setSize(w, h);
    composer.setSize(w, h);
    camera.aspect = aspect;
    camera.updateProjectionMatrix();
    bloomPass.setSize(w, h);
  }
  addEventListener("resize", onResize);

</script>
</body>
</html>
