<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Nebula Meteor Adventure (9:16)</title>
  <style>
    :root{
      --ui-bg: rgba(10,12,18,.55);
      --ui-br: rgba(255,255,255,.08);
      --txt: rgba(255,255,255,.9);
      --muted: rgba(255,255,255,.65);
    }
    html,body{margin:0;height:100%;background:#000;overflow:hidden;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;}
    #wrap{
      position:fixed; inset:0;
      display:flex; align-items:center; justify-content:center;
      background:#000;
      touch-action:none;
    }
    canvas{ display:block; width:100%; height:100%; }
    /* UI */
    #ui{
      position:fixed; left:10px; top:10px; z-index:5;
      max-width:min(520px,calc(100vw - 20px));
      color:var(--txt);
      background:var(--ui-bg);
      border:1px solid var(--ui-br);
      border-radius:18px;
      backdrop-filter: blur(10px);
      padding:12px 12px 10px;
      box-shadow: 0 12px 40px rgba(0,0,0,.45);
    }
    #ui h1{margin:0 0 6px;font-size:16px;letter-spacing:.2px}
    #ui .sub{font-size:12px;color:var(--muted);line-height:1.35;margin-bottom:10px}
    #row{display:flex;gap:8px;flex-wrap:wrap}
    button{
      appearance:none;border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.06);
      color:var(--txt);
      padding:10px 12px;border-radius:14px;
      font-weight:600;font-size:13px;
    }
    button:active{transform:scale(.98)}
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:7px 10px;border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.05);
      font-size:12px; color:var(--muted);
      margin-top:8px;
    }
    #hud{
      position:fixed; left:10px; bottom:10px; z-index:5;
      color:rgba(255,255,255,.65);
      font-size:12px;
      background:rgba(10,12,18,.38);
      border:1px solid rgba(255,255,255,.08);
      border-radius:999px;
      padding:8px 12px;
      backdrop-filter: blur(8px);
      user-select:none;
      max-width: calc(100vw - 20px);
    }
    #romance{
      position:fixed; left:50%; bottom:88px; transform:translateX(-50%);
      z-index:6;
      max-width:min(680px,calc(100vw - 28px));
      padding:12px 14px;
      border-radius:16px;
      background:rgba(10,12,18,.55);
      border:1px solid rgba(255,255,255,.12);
      backdrop-filter: blur(10px);
      color:rgba(255,255,255,.92);
      font-size:14px;
      line-height:1.35;
      opacity:0;
      transition:opacity .25s ease, transform .25s ease;
      pointer-events:none;
      box-shadow: 0 14px 50px rgba(0,0,0,.55);
    }
    #romance.show{
      opacity:1;
      transform:translateX(-50%) translateY(-6px);
    }
    #romance small{display:block;color:rgba(255,255,255,.65);margin-top:4px}
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="c"></canvas>
  </div>

  <div id="ui">
    <h1>üåå Nebula Meteor Adventure (3D, 9:16)</h1>
    <div class="sub">
      ‚Ä¢ Drag = petualangan (geser kamera) ‚Ä¢ Pinch = zoom<br>
      ‚Ä¢ Tap meteor = fokus + kamera ngikutin<br>
      ‚Ä¢ Render hemat: <b>20 meteor terdekat</b>
    </div>
    <div id="row">
      <button id="play">‚ñ∂ Play</button>
      <button id="pause">‚è∏ Pause</button>
      <button id="shuffle">üé≤ Shuffle</button>
      <button id="auto">üß≠ Auto Tour: OFF</button>
      <button id="fs">‚õ∂ Fullscreen</button>
      <button id="rec">üé• Record</button>
      <button id="stop" disabled>‚èπ Stop</button>
    </div>
    <div class="pill" id="stat">Loading...</div>
  </div>

  <div id="romance"></div>
  <div id="hud">Tip: pinch untuk zoom ‚Ä¢ drag untuk petualangan ‚Ä¢ tap meteor untuk fokus</div>

  <audio id="music" src="music.mp3" preload="auto" crossorigin="anonymous"></audio>

  <script>
  (() => {
    // =========================
    // CONFIG (ubah kalau mau)
    // =========================
    const MAX_PHOTOS_TRY = 55;           // auto-detect sampai 55
    const ACTIVE_LIMIT = 20;             // render hemat
    const METEOR_COUNT = 1200;           // "ribuan" di data, tapi aktif cuma 20 terdekat
    const WORLD_RADIUS_MIN = 520;        // jarak sebar (nggak terlalu dekat)
    const WORLD_RADIUS_MAX = 1250;       // jarak sebar (nggak terlalu jauh)
    const MIN_SEP = 55;                 // anti numpuk (semakin besar makin renggang)
    const DRIFT_SPEED = 0.04;           // drift meteor (posisi bergerak halus, bukan muter foto)
    const ORBIT_SWIRL = 0.0015;         // sedikit swirl biar hidup (kecil banget)
    const TAP_FOCUS_ZOOM = 2.3;         // seberapa "mendekat"
    const FOLLOW_STRENGTH = 0.065;      // kamera ngikutin
    const NEBULA_INTENSITY = 1.0;       // nebula lebih keliatan
    const STAR_COUNT = 1000;

    // Romantic texts (punya kamu)
    const ROMANCE_TEXTS = [
      "Aku peduli sama dirimu. ‚ù§Ô∏è",
      "Dimata ku, kamu anak kecil yang jadi penyemangat ku. üè°‚ú®",
      "Aku pasti dibilang buaya karna bikin gini, tapi buaya mana yang mau capek mikir untuk bikin giniüòí",
      "Jangan tinggalin aku.",
      "Aku bakal terus berusaha nyenengin kamu. üòäüíó",
      "Aku bangga sama kamu. üå∑",
    ];

    // =========================
    // Canvas & DPR
    // =========================
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });
    let W=0,H=0,DPR=1;

    function resize(){
      DPR = Math.min(2, window.devicePixelRatio || 1);
      W = Math.floor(window.innerWidth * DPR);
      H = Math.floor(window.innerHeight * DPR);
      canvas.width = W;
      canvas.height = H;
    }
    window.addEventListener('resize', resize, {passive:true});
    resize();

    // =========================
    // Utilities
    // =========================
    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
    const lerp=(a,b,t)=>a+(b-a)*t;
    const rand=(a,b)=>a+Math.random()*(b-a);
    const randi=(a,b)=>Math.floor(rand(a,b+1));
    function pick(arr){ return arr[(Math.random()*arr.length)|0]; }

    // =========================
    // Load photos (auto-detect)
    // =========================
    const photos = [];
    const photoSrcs = [];
    let loadedCount = 0;
    let detectedTotal = 0;

    const stat = document.getElementById('stat');
    function setStat(txt){ stat.textContent = txt; }

    async function tryLoadImage(src){
      return new Promise((resolve) => {
        const img = new Image();
        img.decoding = "async";
        img.loading = "eager";
        img.onload = () => resolve(img);
        img.onerror = () => resolve(null);
        img.src = src;
      });
    }

    (async function loadAll(){
      setStat("Mendeteksi foto di folder fotos/ ...");
      for(let i=1;i<=MAX_PHOTOS_TRY;i++){
        const src = `fotos/${i}.jpg`;
        const img = await tryLoadImage(src);
        if(!img){
          // berhenti saat ketemu yang gagal (asumsi urut)
          break;
        }
        photoSrcs.push(src);
        photos.push(img);
        loadedCount++;
        setStat(`Loaded foto: ${loadedCount} (mencari berikutnya...)`);
      }
      detectedTotal = loadedCount;
      if(detectedTotal === 0){
        setStat("‚ùå Tidak ada foto terdeteksi. Pastikan fotos/1.jpg ada.");
      } else {
        setStat(`‚úÖ Foto terdeteksi: ${detectedTotal}. Menyiapkan meteor...`);
      }
      buildWorld();
    })();

    // =========================
    // World / Camera (pseudo-3D)
    // =========================
    const world = {
      meteors: [],
      stars: [],
      ready: false,
    };

    const cam = {
      // posisi kamera di world
      x: 0, y: 0, z: -980,
      // arah pandang (yaw/pitch)
      yaw: 0.15, pitch: -0.06,
      // zoom (FOV scalar)
      zoom: 1.0,
      targetZoom: 1.0,
      // follow meteor
      followId: -1,
      // autopilot
      auto: false,
      t: 0,
    };

    const center = { x:0, y:0, z:0 };

    // precompute stars (background)
    function buildStars(){
      world.stars.length = 0;
      for(let i=0;i<STAR_COUNT;i++){
        const a = Math.random()*Math.PI*2;
        const u = Math.random()*2-1;
        const r = rand(1200, 5200);
        const s = Math.sqrt(1-u*u);
        const x = Math.cos(a)*s*r;
        const y = u*r;
        const z = Math.sin(a)*s*r;
        world.stars.push({
          x,y,z,
          b: rand(0.35,1.0),
          size: rand(0.6, 1.8),
        });
      }
    }

    // spread meteors with rejection sampling (anti numpuk)
    function generateMeteorPositions(count){
      const pts = [];
      const triesMax = count*25;
      let tries = 0;

      while(pts.length < count && tries < triesMax){
        tries++;

        // shell radius range
        const r = rand(WORLD_RADIUS_MIN, WORLD_RADIUS_MAX);
        const theta = Math.random()*Math.PI*2;
        const phi = Math.acos(rand(-1,1)); // 0..pi
        const sx = Math.sin(phi)*Math.cos(theta);
        const sy = Math.cos(phi);
        const sz = Math.sin(phi)*Math.sin(theta);

        // sedikit bias biar "bentuk awan" lebih cinematic
        const biasY = Math.pow(Math.random(), 1.6) * (Math.random()<0.5?-1:1);
        const x = sx*r;
        const y = (sy*0.65 + biasY*0.35)*r*0.85;
        const z = sz*r;

        // reject if too close to existing
        let ok = true;
        for(let j=0;j<pts.length;j++){
          const p = pts[j];
          const dx=x-p.x, dy=y-p.y, dz=z-p.z;
          if(dx*dx+dy*dy+dz*dz < MIN_SEP*MIN_SEP){
            ok = false; break;
          }
        }
        if(ok) pts.push({x,y,z});
      }

      // kalau masih kurang, isi sisa tanpa reject (jarang)
      while(pts.length < count){
        const r = rand(WORLD_RADIUS_MIN, WORLD_RADIUS_MAX);
        const a = Math.random()*Math.PI*2;
        const u = rand(-1,1);
        const s = Math.sqrt(1-u*u);
        pts.push({
          x: Math.cos(a)*s*r,
          y: u*r*0.7,
          z: Math.sin(a)*s*r
        });
      }
      return pts;
    }

    function buildWorld(){
      buildStars();

      world.meteors.length = 0;
      const pts = generateMeteorPositions(METEOR_COUNT);

      for(let i=0;i<METEOR_COUNT;i++){
        const imgIndex = detectedTotal ? (i % detectedTotal) : 0;
        const p = pts[i];

        // ukuran meteor (kartu 9:16, bukan bulat)
        const baseH = rand(52, 120);          // tinggi kartu di world-unit
        const baseW = baseH * 9/16;

        world.meteors.push({
          id: i,
          imgIndex,
          x: p.x, y: p.y, z: p.z,
          vx: rand(-1,1)*DRIFT_SPEED,
          vy: rand(-1,1)*DRIFT_SPEED*0.6,
          vz: rand(-1,1)*DRIFT_SPEED,
          w: baseW,
          h: baseH,
          // trail memory
          trail: [],
          // clickable last projection
          sx: 0, sy: 0, sw: 0, sh: 0,
          depth: 0,
        });
      }

      world.ready = true;
      setStat(`Loaded: ${detectedTotal}/${MAX_PHOTOS_TRY} ‚Ä¢ Render: 0/${ACTIVE_LIMIT} ‚Ä¢ Zoom: ${cam.zoom.toFixed(2)} ‚Ä¢ Follow: -`);
    }

    // =========================
    // 3D Transform & Projection
    // =========================
    function rotY(x,z,ang){
      const c=Math.cos(ang), s=Math.sin(ang);
      return { x: x*c - z*s, z: x*s + z*c };
    }
    function rotX(y,z,ang){
      const c=Math.cos(ang), s=Math.sin(ang);
      return { y: y*c - z*s, z: y*s + z*c };
    }

    function project(px,py,pz){
      // translate relative camera
      let x = px - cam.x;
      let y = py - cam.y;
      let z = pz - cam.z;

      // rotate opposite (camera orientation)
      // yaw
      let r1 = rotY(x,z,-cam.yaw);
      x = r1.x; z = r1.z;
      // pitch
      let r2 = rotX(y,z,-cam.pitch);
      y = r2.y; z = r2.z;

      // behind camera?
      if(z <= 1) return null;

      // perspective
      const f = (H * 0.9) / (z) * cam.zoom; // scale with zoom
      const sx = (W*0.5) + x*f;
      const sy = (H*0.5) + y*f;

      return { sx, sy, f, z };
    }

    // =========================
    // Input (drag / pinch / tap)
    // =========================
    const pointers = new Map();
    let lastTapTime = 0;

    let dragging = false;
    let dragMode = "pan"; // pan (geser kamera) + yaw/pitch
    let lastX=0,lastY=0;

    function screenToNDC(x,y){
      return { x: x*DPR, y: y*DPR };
    }

    canvas.addEventListener('pointerdown', (e)=>{
      canvas.setPointerCapture(e.pointerId);
      pointers.set(e.pointerId, { x:e.clientX, y:e.clientY });
      if(pointers.size === 1){
        dragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
      }
    });

    canvas.addEventListener('pointermove', (e)=>{
      if(!pointers.has(e.pointerId)) return;
      const p = pointers.get(e.pointerId);
      p.x = e.clientX; p.y = e.clientY;

      // pinch
      if(pointers.size >= 2){
        const arr = Array.from(pointers.values());
        const dx = arr[0].x - arr[1].x;
        const dy = arr[0].y - arr[1].y;
        const dist = Math.hypot(dx,dy);

        if(!canvas._pinchDist){
          canvas._pinchDist = dist;
          canvas._pinchZoom = cam.targetZoom;
        }else{
          const ratio = dist / canvas._pinchDist;
          cam.targetZoom = clamp(canvas._pinchZoom * ratio, 0.45, 4.0);
        }
        return;
      }

      // single drag: pan + rotate
      if(dragging && pointers.size === 1){
        const dx = e.clientX - lastX;
        const dy = e.clientY - lastY;
        lastX = e.clientX; lastY = e.clientY;

        // Gerak: sedikit putar + sedikit geser kamera (petualangan)
        cam.yaw   += dx * 0.0022;
        cam.pitch += dy * 0.0018;
        cam.pitch = clamp(cam.pitch, -1.15, 1.15);

        // geser kamera di plane view (relative yaw)
        const panScale = 1.0 / cam.zoom;
        const panX = -dx * 0.9 * panScale;
        const panY =  dy * 0.9 * panScale;

        // convert pan to world axes based on yaw
        const c = Math.cos(cam.yaw), s = Math.sin(cam.yaw);
        cam.x += (panX*c) - (0*s);
        cam.z += (panX*s) + (0*c);
        cam.y += panY * 0.75;
      }
    }, {passive:false});

    function clearPinch(){
      canvas._pinchDist = null;
      canvas._pinchZoom = null;
    }

    canvas.addEventListener('pointerup', (e)=>{
      pointers.delete(e.pointerId);
      if(pointers.size < 2) clearPinch();
      if(pointers.size === 0){
        dragging = false;

        // tap detect
        const now = performance.now();
        const dt = now - lastTapTime;
        lastTapTime = now;

        // treat as tap if little move
        // We'll do hit test on pointerup using last known e coords
        const hit = pickMeteorAt(e.clientX, e.clientY);
        if(hit){
          focusMeteor(hit);
        } else {
          // double tap for fullscreen
          if(dt < 320){
            toggleFullscreen();
          }
        }
      }
    });

    canvas.addEventListener('pointercancel', ()=>{
      pointers.clear(); dragging=false; clearPinch();
    });

    function pickMeteorAt(cx,cy){
      const p = screenToNDC(cx,cy);
      // check rendered meteors only (performance)
      let best = null;
      let bestZ = Infinity;

      for(const m of renderList){
        // bounding box hit test
        const x = m.sx - m.sw*0.5;
        const y = m.sy - m.sh*0.5;
        if(p.x >= x && p.x <= x+m.sw && p.y >= y && p.y <= y+m.sh){
          if(m.depth < bestZ){
            bestZ = m.depth;
            best = m;
          }
        }
      }
      return best;
    }

    // =========================
    // Focus / Romance text
    // =========================
    const romanceBox = document.getElementById('romance');
    let romanceTimer = 0;

    function showRomance(text, sub){
      romanceBox.innerHTML = `${text}<small>${sub||""}</small>`;
      romanceBox.classList.add('show');
      romanceTimer = 2.6; // seconds
    }

    function focusMeteor(m){
      cam.followId = m.id;
      // zoom in smoothly
      cam.targetZoom = clamp(cam.zoom * TAP_FOCUS_ZOOM, 0.8, 4.0);

      // show romantic text (random)
      const text = pick(ROMANCE_TEXTS);
      const label = `(foto ${m.imgIndex+1}.jpg)`;
      showRomance(text, label);
      updateStat();
    }

    // =========================
    // Music + Beat (simple)
    // =========================
    const music = document.getElementById('music');
    let audioCtx=null, analyser=null, dataArr=null, beat=0;

    async function initAudio(){
      if(audioCtx) return true;
      try{
        audioCtx = new (window.AudioContext||window.webkitAudioContext)();
        const src = audioCtx.createMediaElementSource(music);
        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 256;
        dataArr = new Uint8Array(analyser.frequencyBinCount);
        src.connect(analyser);
        analyser.connect(audioCtx.destination);
        return true;
      }catch(e){
        console.warn("Audio init failed:", e);
        return false;
      }
    }

    function updateBeat(){
      if(!analyser) { beat = 0; return; }
      analyser.getByteFrequencyData(dataArr);
      // average low-mid for beat-ish
      let sum=0;
      const n = Math.min(48, dataArr.length);
      for(let i=0;i<n;i++) sum += dataArr[i];
      const avg = sum/(n*255);
      // smooth
      beat = lerp(beat, avg, 0.14);
    }

    // =========================
    // Recording (WebM)
    // =========================
    let recorder=null, recChunks=[];
    let recStream=null;

    async function startRecord(){
      try{
        const fps = 30;
        const stream = canvas.captureStream(fps);

        // try add audio track
        let outStream = stream;
        try{
          if(!audioCtx) await initAudio();
          if(audioCtx){
            // route audio to destination stream
            const dest = audioCtx.createMediaStreamDestination();
            // connect analyser output chain already goes to destination, so duplicate:
            // easiest: connect music element again via media element source is already used.
            // If already created, we can connect analyser to dest too:
            // (analyser isn't a node output; connect the source to dest instead)
            // We'll just connect music element to dest by creating another source is not allowed.
            // So, fallback: no audio for some browsers.
            // Some browsers allow capture audio via getUserMedia, but too heavy.
            // => keep best-effort, video-only.
          }
        }catch(e){}

        recStream = outStream;
        const mime = MediaRecorder.isTypeSupported('video/webm;codecs=vp9')
          ? 'video/webm;codecs=vp9'
          : (MediaRecorder.isTypeSupported('video/webm;codecs=vp8') ? 'video/webm;codecs=vp8' : 'video/webm');
        recorder = new MediaRecorder(recStream, { mimeType: mime, videoBitsPerSecond: 4_000_000 });

        recChunks = [];
        recorder.ondataavailable = (ev)=>{ if(ev.data && ev.data.size) recChunks.push(ev.data); };
        recorder.onstop = ()=>{
          const blob = new Blob(recChunks, { type: recorder.mimeType });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'nebula-meteor-adventure.webm';
          document.body.appendChild(a);
          a.click();
          a.remove();
          setTimeout(()=>URL.revokeObjectURL(url), 5000);
        };
        recorder.start(200);

        document.getElementById('rec').disabled = true;
        document.getElementById('stop').disabled = false;
        showRomance("üé• Recording dimulai!", "Nanti otomatis ke-download saat Stop");
      }catch(e){
        showRomance("‚ùå Record gagal di browser ini.", "Coba Chrome / Firefox");
        console.warn(e);
      }
    }

    function stopRecord(){
      try{
        if(recorder && recorder.state !== 'inactive') recorder.stop();
      }catch(e){}
      recorder=null;
      document.getElementById('rec').disabled = false;
      document.getElementById('stop').disabled = true;
      showRomance("‚úÖ Recording berhenti.", "File WebM sedang disiapkan...");
    }

    // =========================
    // Fullscreen
    // =========================
    async function toggleFullscreen(){
      try{
        if(!document.fullscreenElement){
          await document.documentElement.requestFullscreen();
        }else{
          await document.exitFullscreen();
        }
      }catch(e){}
    }

    // =========================
    // UI buttons
    // =========================
    document.getElementById('play').onclick = async () => {
      await initAudio();
      try{ if(audioCtx && audioCtx.state === 'suspended') await audioCtx.resume(); }catch(e){}
      try{ await music.play(); showRomance("üé∂ Musik jalan!", "Kalau gak bunyi: cek volume / izin browser"); }catch(e){
        showRomance("‚ö†Ô∏è Browser minta klik lagi untuk play musik.", "Coba pencet Play sekali lagi");
      }
    };
    document.getElementById('pause').onclick = () => { music.pause(); };
    document.getElementById('shuffle').onclick = () => {
      if(!world.ready) return;
      // acak assignment foto biar beda vibe, posisi tetap
      for(const m of world.meteors){
        m.imgIndex = randi(0, Math.max(0,detectedTotal-1));
      }
      showRomance("üé≤ Shuffle foto!", "Susunan foto di meteor berubah");
    };
    document.getElementById('auto').onclick = () => {
      cam.auto = !cam.auto;
      document.getElementById('auto').textContent = cam.auto ? "üß≠ Auto Tour: ON" : "üß≠ Auto Tour: OFF";
      showRomance(cam.auto ? "üß≠ Auto Tour ON" : "üß≠ Auto Tour OFF", "Kamera jalan sendiri pelan-pelan");
    };
    document.getElementById('fs').onclick = toggleFullscreen;
    document.getElementById('rec').onclick = startRecord;
    document.getElementById('stop').onclick = stopRecord;

    // =========================
    // Render list (nearest 20)
    // =========================
    let renderList = [];

    function computeNearest(){
      // distance in camera space before rotation (cheap)
      // We use world distance to cam pos (good enough)
      const arr = world.meteors;
      for(const m of arr){
        const dx = m.x - cam.x;
        const dy = m.y - cam.y;
        const dz = m.z - cam.z;
        m._d2 = dx*dx + dy*dy + dz*dz;
      }
      // partial selection: sort slice (ok for 1200)
      arr.sort((a,b)=>a._d2-b._d2);
      renderList = arr.slice(0, ACTIVE_LIMIT);

      // set fade for others none (not rendered)
    }

    function updateStat(){
      const followText = cam.followId >= 0 ? `foto ${(world.meteors[cam.followId]?.imgIndex||0)+1}.jpg` : '-';
      setStat(`Loaded: ${detectedTotal}/${MAX_PHOTOS_TRY} ‚Ä¢ Render: ${renderList.length}/${ACTIVE_LIMIT} ‚Ä¢ Zoom: ${cam.zoom.toFixed(2)} ‚Ä¢ Follow: ${followText}`);
    }

    // =========================
    // Draw Nebula + Stars
    // =========================
    function drawNebula(){
      // deep space base
      ctx.fillStyle = '#03050a';
      ctx.fillRect(0,0,W,H);

      // cinematic nebula layers (radial gradients)
      const cx = W*0.52;
      const cy = H*0.42;

      function blob(x,y,r, c1, c2, a1=0.55, a2=0){
        const g = ctx.createRadialGradient(x,y,0, x,y,r);
        g.addColorStop(0, `rgba(${c1[0]},${c1[1]},${c1[2]},${a1*NEBULA_INTENSITY})`);
        g.addColorStop(1, `rgba(${c2[0]},${c2[1]},${c2[2]},${a2})`);
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(x,y,r,0,Math.PI*2);
        ctx.fill();
      }

      blob(cx,cy, H*0.85, [60,110,255], [0,0,0], 0.20, 0);
      blob(cx*0.95, cy*1.18, H*0.75, [180,60,255], [0,0,0], 0.16, 0);
      blob(cx*1.18, cy*0.88, H*0.70, [0,220,200], [0,0,0], 0.12, 0);
      blob(cx*0.72, cy*0.60, H*0.65, [255,80,130], [0,0,0], 0.10, 0);

      // vignette
      const vg = ctx.createRadialGradient(W/2,H/2, Math.min(W,H)*0.15, W/2,H/2, Math.max(W,H)*0.65);
      vg.addColorStop(0, 'rgba(0,0,0,0)');
      vg.addColorStop(1, 'rgba(0,0,0,0.55)');
      ctx.fillStyle = vg;
      ctx.fillRect(0,0,W,H);

      // stars (2D projection)
      // do a very cheap star draw without full rotation calc for each; use camera rotation for nicer parallax
      ctx.save();
      ctx.globalAlpha = 0.9;
      for(const s of world.stars){
        const pr = project(s.x,s.y,s.z);
        if(!pr) continue;
        // small stars
        const alpha = clamp(s.b * (1.2 - pr.z/6000), 0.05, 0.8);
        ctx.globalAlpha = alpha;
        const size = s.size * pr.f * 0.0015;
        ctx.fillStyle = 'rgba(255,255,255,1)';
        ctx.fillRect(pr.sx - size*0.5, pr.sy - size*0.5, size, size);
      }
      ctx.restore();

      // subtle grain
      ctx.save();
      ctx.globalAlpha = 0.06;
      ctx.fillStyle = '#fff';
      for(let i=0;i<180;i++){
        const x = (Math.random()*W)|0;
        const y = (Math.random()*H)|0;
        ctx.fillRect(x,y,1,1);
      }
      ctx.restore();
    }

    // =========================
    // Meteor draw (billboard card 9:16)
    // =========================
    function drawMeteor(m, pr){
      const img = photos[m.imgIndex];
      if(!img) return;

      // size in screen
      const sh = m.h * pr.f * 0.012; // scale factor
      const sw = sh * 9/16;

      m.sx = pr.sx; m.sy = pr.sy;
      m.sw = sw; m.sh = sh;
      m.depth = pr.z;

      // trail store (for glow trail)
      m.trail.push({ x: pr.sx, y: pr.sy });
      if(m.trail.length > 16) m.trail.shift();

      // glow trail
      ctx.save();
      ctx.lineCap = "round";
      for(let i=1;i<m.trail.length;i++){
        const a = i / m.trail.length;
        ctx.globalAlpha = 0.18 * a;
        ctx.strokeStyle = "rgba(120,200,255,1)";
        ctx.lineWidth = (3 + 10*a) * DPR;
        ctx.beginPath();
        ctx.moveTo(m.trail[i-1].x, m.trail[i-1].y);
        ctx.lineTo(m.trail[i].x, m.trail[i].y);
        ctx.stroke();
      }
      ctx.restore();

      // card shadow + glow
      ctx.save();
      const glow = 0.22 + beat*0.55;
      ctx.globalAlpha = 1;
      ctx.shadowColor = `rgba(90,180,255,${0.35*glow})`;
      ctx.shadowBlur = 28 * DPR * glow;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 0;

      // rounded rect clip
      const r = 12 * DPR;
      const x = pr.sx - sw/2;
      const y = pr.sy - sh/2;

      ctx.beginPath();
      roundRect(ctx, x, y, sw, sh, r);
      ctx.closePath();
      ctx.clip();

      // draw image cover
      const iw = img.naturalWidth || img.width;
      const ih = img.naturalHeight || img.height;

      // cover fit
      const targetAR = (sw/sh);
      const imgAR = iw/ih;
      let sx=0, sy=0, sW=iw, sH=ih;

      if(imgAR > targetAR){
        // crop sides
        sW = ih * targetAR;
        sx = (iw - sW)/2;
      }else{
        // crop top/bottom
        sH = iw / targetAR;
        sy = (ih - sH)/2;
      }

      ctx.drawImage(img, sx, sy, sW, sH, x, y, sw, sh);

      // overlay subtle film
      ctx.fillStyle = "rgba(0,0,0,0.10)";
      ctx.fillRect(x,y,sw,sh);

      // border
      ctx.restore();
      ctx.save();
      ctx.globalAlpha = 0.9;
      ctx.strokeStyle = "rgba(255,255,255,0.18)";
      ctx.lineWidth = 2 * DPR;
      roundRect(ctx, x, y, sw, sh, r);
      ctx.stroke();
      ctx.restore();
    }

    function roundRect(ctx, x, y, w, h, r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }

    // =========================
    // Update simulation
    // =========================
    function update(dt){
      if(!world.ready) return;

      // smooth zoom
      cam.zoom = lerp(cam.zoom, cam.targetZoom, 0.10);

      // update beat
      updateBeat();

      // auto tour (jalan pelan)
      cam.t += dt;
      if(cam.auto){
        cam.yaw += 0.0007 * (1 + beat*1.4);
        cam.pitch = lerp(cam.pitch, Math.sin(cam.t*0.00035)*0.22, 0.02);
        // slow wander
        cam.x += Math.cos(cam.t*0.00045)*0.06;
        cam.y += Math.sin(cam.t*0.00038)*0.05;
      }

      // move meteors slightly (hidup) + tiny swirl around center
      const swirl = ORBIT_SWIRL * (1 + beat*1.2);
      for(const m of world.meteors){
        // drift
        m.x += m.vx * dt;
        m.y += m.vy * dt;
        m.z += m.vz * dt;

        // wrap softly (keep within sphere band)
        const rx = m.x, ry=m.y, rz=m.z;
        const r = Math.hypot(rx,ry,rz);
        if(r < WORLD_RADIUS_MIN*0.85 || r > WORLD_RADIUS_MAX*1.15){
          // pull back to band
          const k = clamp((WORLD_RADIUS_MIN + WORLD_RADIUS_MAX)*0.5 / (r||1), 0.7, 1.4);
          m.x *= k; m.y *= k; m.z *= k;
        }

        // swirl around Y axis (bukan muter foto, cuma orbit posisi sedikit)
        const c=Math.cos(swirl*dt), s=Math.sin(swirl*dt);
        const nx = m.x*c - m.z*s;
        const nz = m.x*s + m.z*c;
        m.x = nx; m.z = nz;
      }

      // nearest list
      computeNearest();

      // follow camera to selected meteor
      if(cam.followId >= 0){
        const fm = world.meteors[cam.followId];
        if(fm){
          // desired camera position: slightly behind camera direction but toward meteor
          cam.x = lerp(cam.x, fm.x, FOLLOW_STRENGTH);
          cam.y = lerp(cam.y, fm.y, FOLLOW_STRENGTH);
          // keep some distance in front so it fills screen but not clip
          cam.z = lerp(cam.z, fm.z - 620, FOLLOW_STRENGTH);

          // aim camera gently to meteor
          // approximate yaw/pitch from vector
          const vx = (fm.x - cam.x);
          const vy = (fm.y - cam.y);
          const vz = (fm.z - cam.z);
          const desiredYaw = Math.atan2(vx, vz);
          const desiredPitch = -Math.atan2(vy, Math.hypot(vx,vz));
          cam.yaw = lerpAngle(cam.yaw, desiredYaw, 0.06);
          cam.pitch = lerp(cam.pitch, desiredPitch, 0.06);
        }
      }

      // romance hide timer
      if(romanceTimer > 0){
        romanceTimer -= dt/1000;
        if(romanceTimer <= 0){
          romanceBox.classList.remove('show');
        }
      }
    }

    function lerpAngle(a,b,t){
      let d = b - a;
      while(d > Math.PI) d -= Math.PI*2;
      while(d < -Math.PI) d += Math.PI*2;
      return a + d*t;
    }

    // =========================
    // Render
    // =========================
    function render(){
      if(!world.ready){
        // loading screen
        ctx.fillStyle = "#000";
        ctx.fillRect(0,0,W,H);
        ctx.fillStyle = "rgba(255,255,255,.85)";
        ctx.font = `${18*DPR}px system-ui`;
        ctx.fillText("Loading...", 20*DPR, 40*DPR);
        requestAnimationFrame(loop);
        return;
      }

      drawNebula();

      // draw meteors from far to near (depth sort inside renderList)
      const drawList = renderList.slice();
      // compute projection first (and cull)
      const projected = [];
      for(const m of drawList){
        const pr = project(m.x,m.y,m.z);
        if(!pr) continue;
        // fade out if too far (extra cull)
        if(pr.z > 5200) continue;
        projected.push({ m, pr });
      }
      projected.sort((a,b)=>b.pr.z - a.pr.z);

      // clear trails of non-rendered quickly (keep memory low)
      // (renderList changes frequently)
      for(const m of world.meteors){
        if(m._d2 && m._d2 > world.meteors[ACTIVE_LIMIT-1]?._d2){
          // do nothing, too expensive
        }
      }

      // draw
      for(const item of projected){
        drawMeteor(item.m, item.pr);
      }

      // center glow (nebula core highlight)
      ctx.save();
      const g = ctx.createRadialGradient(W*0.5,H*0.55, 0, W*0.5,H*0.55, H*0.22);
      g.addColorStop(0, `rgba(120,220,255,${0.10 + beat*0.18})`);
      g.addColorStop(1, `rgba(0,0,0,0)`);
      ctx.fillStyle = g;
      ctx.fillRect(0,0,W,H);
      ctx.restore();

      updateStat();
      requestAnimationFrame(loop);
    }

    // =========================
    // Main loop
    // =========================
    let last = performance.now();
    function loop(now){
      const dt = now - last;
      last = now;
      update(dt);
      render();
    }
    requestAnimationFrame(loop);

  })();
  </script>
</body>
</html>
