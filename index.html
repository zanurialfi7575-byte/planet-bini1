<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,height=device-height,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
  <title>Nebula Meteor Adventure</title>
  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:#000;touch-action:none;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
    canvas{display:block}

    #ui{
      position:fixed;left:12px;top:12px;z-index:10;
      background:rgba(18,18,26,.62);backdrop-filter:blur(10px);
      border-radius:14px;padding:12px;color:#fff;font-size:12px;line-height:1.25;
      max-width:min(420px,92vw)
    }
    #ui b{font-size:13px}
    #ui .row{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
    #ui button{
      background:#24242e;border:0;color:#fff;border-radius:10px;padding:8px 10px;font-size:12px
    }
    #ui button:active{transform:scale(.98)}
    #hud{
      position:fixed;left:12px;bottom:12px;z-index:10;
      color:#bbb;font-size:12px;opacity:.8;background:rgba(0,0,0,.35);
      padding:8px 10px;border-radius:12px;backdrop-filter:blur(10px)
    }
    #love{
      position:fixed;left:50%;top:62%;
      transform:translate(-50%,-50%);
      z-index:11;color:#fff;font-size:18px;text-align:center;
      padding:14px 16px;border-radius:18px;
      background:rgba(0,0,0,.45);backdrop-filter:blur(10px);
      max-width:min(560px,90vw);
      opacity:0;pointer-events:none;
      transition:opacity .25s ease;
      text-shadow:0 8px 22px rgba(0,0,0,.8);
    }
    #love small{display:block;font-size:12px;color:#ddd;opacity:.85;margin-top:6px}
    #err{
      position:fixed;inset:0;display:none;align-items:center;justify-content:center;
      background:#0b0b10;color:#fff;z-index:9999;padding:20px;text-align:left
    }
    #err pre{
      white-space:pre-wrap;background:rgba(255,255,255,.06);padding:14px;border-radius:12px;
      max-width:900px;width:100%
    }
  </style>
</head>
<body>

<div id="ui">
  <b>üåå Nebula Meteor Adventure (3D, 9:16)</b><br>
  ‚Ä¢ Drag = puter dunia ‚Ä¢ Pinch = zoom ‚Ä¢ Tap meteor = fokus<br>
  ‚Ä¢ Render hemat: <b>20 meteor terdekat</b><br>
  <div class="row">
    <button id="btnPlay">‚ñ∂ Play</button>
    <button id="btnPause">‚è∏ Pause</button>
    <button id="btnAuto">üß≠ Auto Tour: OFF</button>
    <button id="btnShuffle">üé≤ Shuffle</button>
    <button id="btnFS">‚õ∂ Fullscreen</button>
  </div>
  <div class="row">
    <button id="btnRec">üé• Record</button>
    <button id="btnStop" disabled>‚èπ Stop</button>
  </div>
</div>

<div id="love"></div>
<div id="hud">Loading‚Ä¶</div>

<div id="err"><pre id="errTxt"></pre></div>

<audio id="music" src="music.mp3" loop></audio>

<!-- Three.js global (lebih aman di HP dibanding import module) -->
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>
(() => {
  const hud = document.getElementById("hud");
  const loveBox = document.getElementById("love");
  const music = document.getElementById("music");
  const errWrap = document.getElementById("err");
  const errTxt = document.getElementById("errTxt");

  function showErr(e){
    console.error(e);
    errWrap.style.display="flex";
    errTxt.textContent =
`‚ö†Ô∏è Ada error, makanya layar jadi putih.

Detail:
${(e && (e.stack||e.message)) ? (e.stack||e.message) : String(e)}

‚úÖ Cek ini:
1) Nama folder foto harus persis: fotos/
2) Foto harus: fotos/1.jpg ... fotos/N.jpg
3) music harus: music.mp3 (root)
4) Coba buka link pakai ?v=2 (biar cache kebuang)
`;
  }

  try {
    /* ================= CONFIG ================= */
    const TOTAL_PHOTO   = 43;     // ganti 55 kalau sudah 55
    const MAX_RENDER    = 20;     // render meteor terdekat (anti lag)
    const METEOR_COUNT  = 1400;   // data meteor (bukan mesh semua)
    const PHOTO_ASPECT  = 9/16;   // portrait 9:16
    const BASE_H        = 26;     // ukuran foto (world units)
    const R_MIN         = 170;
    const R_MAX         = 560;
    const ORBIT_SPEED   = 0.00042;
    const NEBULA_SIZE   = 2600;

    /* ================= UI / AUDIO ================= */
    document.getElementById("btnPlay").onclick = () => music.play().catch(()=>{});
    document.getElementById("btnPause").onclick = () => music.pause();

    let autoTour = false;
    const btnAuto = document.getElementById("btnAuto");
    btnAuto.onclick = () => {
      autoTour = !autoTour;
      btnAuto.textContent = `üß≠ Auto Tour: ${autoTour ? "ON" : "OFF"}`;
      if (autoTour) followIndex = -1;
    };

    document.getElementById("btnFS").onclick = async () => {
      try {
        if(!document.fullscreenElement) await document.documentElement.requestFullscreen();
        else await document.exitFullscreen();
      } catch(e){}
    };

    /* ================= RECORD WebM ================= */
    let mediaRecorder = null;
    let recordedChunks = [];
    const btnRec = document.getElementById("btnRec");
    const btnStop = document.getElementById("btnStop");

    function downloadBlob(blob, filename){
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(()=>URL.revokeObjectURL(url), 1500);
    }

    btnRec.onclick = () => {
      try{
        const stream = renderer.domElement.captureStream(30);
        recordedChunks = [];
        mediaRecorder = new MediaRecorder(stream, { mimeType: "video/webm;codecs=vp9" });
        mediaRecorder.ondataavailable = (e)=>{ if(e.data && e.data.size) recordedChunks.push(e.data); };
        mediaRecorder.onstop = ()=>{
          const blob = new Blob(recordedChunks, { type:"video/webm" });
          downloadBlob(blob, "nebula-meteor.webm");
        };
        mediaRecorder.start();
        btnRec.disabled = true;
        btnStop.disabled = false;
      }catch(e){
        // fallback vp8
        try{
          const stream = renderer.domElement.captureStream(30);
          recordedChunks = [];
          mediaRecorder = new MediaRecorder(stream, { mimeType: "video/webm;codecs=vp8" });
          mediaRecorder.ondataavailable = (e)=>{ if(e.data && e.data.size) recordedChunks.push(e.data); };
          mediaRecorder.onstop = ()=>{
            const blob = new Blob(recordedChunks, { type:"video/webm" });
            downloadBlob(blob, "nebula-meteor.webm");
          };
          mediaRecorder.start();
          btnRec.disabled = true;
          btnStop.disabled = false;
        }catch(err){
          alert("HP kamu gak support record WebM di browser ini üò≠\nCoba Chrome terbaru / browser lain.");
        }
      }
    };

    btnStop.onclick = () => {
      if(mediaRecorder && mediaRecorder.state !== "inactive"){
        mediaRecorder.stop();
      }
      btnRec.disabled = false;
      btnStop.disabled = true;
    };

    /* ================= SCENE ================= */
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.00072);

    const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:"high-performance" });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 1.6));
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    document.body.appendChild(renderer.domElement);

    const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 12000);
    camera.position.set(0, 0, 820);

    addEventListener("resize", () => {
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const key = new THREE.DirectionalLight(0xffffff, 0.7);
    key.position.set(600, 900, 700);
    scene.add(key);

    // WORLD group yang diputer biar kerasa 3D
    const world = new THREE.Group();
    scene.add(world);

    /* ================= STARS ================= */
    function makeStars(count=3200){
      const g = new THREE.BufferGeometry();
      const pos = new Float32Array(count*3);
      for(let i=0;i<count;i++){
        const r = 2400 + Math.random()*3200;
        const a = Math.random()*Math.PI*2;
        const b = (Math.random()*2-1);
        pos[i*3+0] = Math.cos(a)*r;
        pos[i*3+2] = Math.sin(a)*r;
        pos[i*3+1] = b*420 + (Math.random()*2-1)*700;
      }
      g.setAttribute("position", new THREE.BufferAttribute(pos,3));
      const m = new THREE.PointsMaterial({ size:2.2, color:0xffffff, transparent:true, opacity:0.75, depthWrite:false });
      return new THREE.Points(g,m);
    }
    scene.add(makeStars());

    /* ================= NEBULA (canvas sprite) ================= */
    function makeNebula(){
      const c = document.createElement("canvas");
      c.width = 1024; c.height = 1024;
      const x = c.getContext("2d");
      x.clearRect(0,0,c.width,c.height);

      function blob(cx,cy,r, colA, colB){
        const g = x.createRadialGradient(cx,cy, 10, cx,cy,r);
        g.addColorStop(0, colA);
        g.addColorStop(1, colB);
        x.fillStyle = g;
        x.beginPath(); x.arc(cx,cy,r,0,Math.PI*2); x.fill();
      }
      blob(520,520,520, "rgba(170,80,255,0.62)", "rgba(0,0,0,0)");
      blob(460,560,470, "rgba(80,220,255,0.45)", "rgba(0,0,0,0)");
      blob(580,480,420, "rgba(255,120,180,0.35)", "rgba(0,0,0,0)");
      blob(520,520,300, "rgba(255,255,255,0.20)", "rgba(0,0,0,0)");

      // noise
      const img = x.getImageData(0,0,c.width,c.height);
      for(let i=0;i<img.data.length;i+=4){
        const n = (Math.random()-0.5)*26;
        img.data[i+0]=Math.min(255, img.data[i+0] + n);
        img.data[i+1]=Math.min(255, img.data[i+1] + n);
        img.data[i+2]=Math.min(255, img.data[i+2] + n);
      }
      x.putImageData(img,0,0);

      const tex = new THREE.CanvasTexture(c);
      tex.colorSpace = THREE.SRGBColorSpace;

      const mat = new THREE.SpriteMaterial({
        map: tex,
        transparent:true,
        opacity: 1,
        depthWrite:false,
        blending: THREE.AdditiveBlending
      });

      const spr = new THREE.Sprite(mat);
      spr.scale.set(NEBULA_SIZE, NEBULA_SIZE, 1);
      spr.position.set(0,0,0);
      return spr;
    }
    const nebula = makeNebula();
    world.add(nebula);

    /* ================= METEOR DATA 3D ================= */
    function rand3D(){
      // sebaran debris 3D (nggak ring rapih)
      const t = Math.random();
      const r = Math.sqrt(t*(R_MAX*R_MAX - R_MIN*R_MIN) + R_MIN*R_MIN);
      const a = Math.random()*Math.PI*2;

      const thickness = (Math.random()*2-1) * 190;  // lebih ‚Äúspace‚Äù
      const warp = (Math.random()*2-1) * 90;

      const x = Math.cos(a)*r + warp;
      const z = Math.sin(a)*r - warp;
      const y = thickness + Math.sin(a*2.6)*30;

      return {x,y,z,r,a};
    }

    const meteors = [];
    for(let i=0;i<METEOR_COUNT;i++){
      const p = rand3D();
      meteors.push({
        photoId: 1 + (i % TOTAL_PHOTO),
        x:p.x, y:p.y, z:p.z,
        r:p.r,
        ang:p.a,
        speed: (0.65 + Math.random()*1.1),
        rx: (Math.random()*2-1) * 0.9,
        ry: (Math.random()*2-1) * Math.PI,
        rz: (Math.random()*2-1) * 0.5,
        spin: (Math.random()*2-1) * 0.018,
        // velocity cache for trail
        vx:0, vy:0, vz:0,
        px:p.x, py:p.y, pz:p.z
      });
    }

    /* ================= LOAD TEXTURES ================= */
    const loader = new THREE.TextureLoader();
    const photoTex = new Array(TOTAL_PHOTO+1);
    let loaded = 0;

    for(let i=1;i<=TOTAL_PHOTO;i++){
      loader.load(`fotos/${i}.jpg`, (t)=>{
        t.colorSpace = THREE.SRGBColorSpace;
        t.anisotropy = 2;
        photoTex[i]=t;
        loaded++;
      }, undefined, (err)=> {
        // biar kelihatan kalau ada 404
        console.warn("Gagal load:", `fotos/${i}.jpg`, err);
      });
    }

    /* ================= POOL 20 METEOR RECTANGLE 9:16 ================= */
    const geom = new THREE.PlaneGeometry(BASE_H*PHOTO_ASPECT, BASE_H, 1, 1);

    function makeMat(tex){
      return new THREE.MeshBasicMaterial({
        map: tex || null,
        transparent:true,
        opacity:1,
        side:THREE.DoubleSide,
        depthWrite:false
      });
    }

    // glow overlay (ringan)
    const glowGeom = new THREE.PlaneGeometry(BASE_H*PHOTO_ASPECT*1.18, BASE_H*1.18, 1, 1);
    const glowMat = new THREE.MeshBasicMaterial({
      color:0xffffff,
      transparent:true,
      opacity:0.18,
      blending: THREE.AdditiveBlending,
      depthWrite:false
    });

    // trail geometry (stretched plane)
    const trailGeom = new THREE.PlaneGeometry(BASE_H*PHOTO_ASPECT*0.7, BASE_H*2.4, 1, 1);
    const trailMat = new THREE.MeshBasicMaterial({
      color:0x9be7ff,
      transparent:true,
      opacity:0.12,
      blending: THREE.AdditiveBlending,
      depthWrite:false
    });

    const pool = [];
    const poolGlow = [];
    const poolTrail = [];

    for(let i=0;i<MAX_RENDER;i++){
      const m = new THREE.Mesh(geom, makeMat(null));
      m.visible = false;
      scene.add(m);
      pool.push(m);

      const g = new THREE.Mesh(glowGeom, glowMat.clone());
      g.visible = false;
      scene.add(g);
      poolGlow.push(g);

      const tr = new THREE.Mesh(trailGeom, trailMat.clone());
      tr.visible = false;
      scene.add(tr);
      poolTrail.push(tr);
    }

    /* ================= LOVE LINES ================= */
    const loveLines = new Map([
      [1,  "aku butuh kamu untuk jadi penyemangat. üåå‚ù§Ô∏è"],
      [2,  "kalau kamu capek, sini‚Äîaku peluk dari jauh. ü§ç"],
      [3,  "aku udah janji ke diri sendiri gak bakal ninggalin kamu. ‚ú®"],
      [7,  "pasti dibilang buaya karna bikin giniüòí"],
      [13, "ini bukti kalo aku memang beneran suka sama muüòå"],
    ]);

    /* ================= INPUT (rotate world + zoom) ================= */
    let yaw = 0.25, pitch = 0.08;
    let dist = 820, targetDist = 820;

    let dragging=false, lastX=0, lastY=0;
    const dom = renderer.domElement;

    dom.addEventListener("pointerdown",(e)=>{
      dragging=true; lastX=e.clientX; lastY=e.clientY;
    });
    dom.addEventListener("pointermove",(e)=>{
      if(!dragging) return;
      const dx = e.clientX-lastX;
      const dy = e.clientY-lastY;
      yaw   -= dx*0.0042;
      pitch -= dy*0.0036;
      pitch = Math.max(-0.95, Math.min(0.95, pitch));
      lastX=e.clientX; lastY=e.clientY;
      followIndex = -1;
      targetDist = Math.max(260, targetDist);
    });
    dom.addEventListener("pointerup",()=> dragging=false);
    dom.addEventListener("pointercancel",()=> dragging=false);

    // pinch zoom
    let lastPinch=null;
    dom.addEventListener("touchmove",(e)=>{
      if(e.touches.length!==2) return;
      e.preventDefault();
      const dx = e.touches[0].clientX - e.touches[1].clientX;
      const dy = e.touches[0].clientY - e.touches[1].clientY;
      const d = Math.hypot(dx,dy);
      if(lastPinch){
        const ratio = d/lastPinch;
        targetDist = THREE.MathUtils.clamp(targetDist/ratio, 220, 1600);
      }
      lastPinch = d;
    },{passive:false});
    dom.addEventListener("touchend",()=> lastPinch=null);

    dom.addEventListener("wheel",(e)=>{
      e.preventDefault();
      targetDist = THREE.MathUtils.clamp(targetDist + e.deltaY*0.35, 220, 1600);
    },{passive:false});

    /* ================= SHUFFLE ================= */
    document.getElementById("btnShuffle").onclick = ()=>{
      for(const m of meteors){
        const p = rand3D();
        m.x=p.x; m.y=p.y; m.z=p.z; m.r=p.r; m.ang=p.a;
        m.px=m.x; m.py=m.y; m.pz=m.z;
      }
      followIndex=-1;
      loveBox.style.opacity = 0;
    };

    /* ================= RAYCAST TAP -> FOLLOW + ZOOM "FULL" ================= */
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let followIndex = -1;

    function pickTap(x,y){
      const rect = dom.getBoundingClientRect();
      mouse.x = ((x-rect.left)/rect.width)*2 - 1;
      mouse.y = -(((y-rect.top)/rect.height)*2 - 1);
      raycaster.setFromCamera(mouse, camera);

      const hits = raycaster.intersectObjects(pool, true);
      if(hits.length){
        const obj = hits[0].object;
        const pi = pool.indexOf(obj);
        if(pi>=0 && pool[pi].userData.dataIndex>=0){
          followIndex = pool[pi].userData.dataIndex;

          // auto zoom ‚Äúfull layar‚Äù
          targetDist = 260; // lebih dekat
          autoTour = false;
          btnAuto.textContent = "üß≠ Auto Tour: OFF";

          // teks romantis muncul (kalau ada)
          const photoId = meteors[followIndex].photoId;
          const line = loveLines.get(photoId) || "jangan tinggalin aku ya. ‚ù§Ô∏è";
          loveBox.innerHTML = `${line}<small>(tap foto buat fokus)</small>`;
          loveBox.style.opacity = 1;

          // coba auto play music (browser kadang blok)
          music.play().catch(()=>{});
        }
      }
    }

    let tapStart=null;
    dom.addEventListener("pointerdown",(e)=>{
      tapStart = {x:e.clientX,y:e.clientY,t:performance.now()};
    });
    dom.addEventListener("pointerup",(e)=>{
      if(!tapStart) return;
      const moved = Math.hypot(e.clientX-tapStart.x, e.clientY-tapStart.y);
      const dt = performance.now()-tapStart.t;
      if(moved<10 && dt<350) pickTap(e.clientX,e.clientY);
      tapStart=null;
    });

    /* ================= AUTO TOUR ================= */
    const clock = new THREE.Clock();

    // tombol auto tour (petualangan)
    document.getElementById("btnAuto").onclick = () => {
      autoTour = !autoTour;
      btnAuto.textContent = `üß≠ Auto Tour: ${autoTour ? "ON" : "OFF"}`;
      followIndex = -1;
      if(autoTour) loveBox.style.opacity = 0;
    };

    let tourTimer = 0;
    let tourTarget = Math.floor(Math.random()*meteors.length);

    function updateCameraWorld(dt){
      dist = THREE.MathUtils.lerp(dist, targetDist, 0.10);

      camera.position.set(0, 0, dist);
      camera.lookAt(0,0,0);

      // rotate world => kerasa 3D
      world.rotation.y = yaw;
      world.rotation.x = pitch;

      // nebula selalu ngadep kamera (biar glow-nya cakep)
      nebula.quaternion.copy(camera.quaternion);

      if(autoTour){
        yaw += 0.35*dt;
        pitch = THREE.MathUtils.lerp(pitch, Math.sin(clock.elapsedTime*0.35)*0.18, 0.02);
        targetDist = THREE.MathUtils.lerp(targetDist, 640 + Math.sin(clock.elapsedTime*0.55)*70, 0.02);

        tourTimer += dt;
        if(tourTimer > 2.8){
          tourTimer = 0;
          tourTarget = Math.floor(Math.random()*meteors.length);
          followIndex = tourTarget;
          targetDist = 300;
        }
      }

      // follow meteor => kamera fokus (petualangan lihat foto)
      if(followIndex>=0){
        const m = meteors[followIndex];
        const v = new THREE.Vector3(m.x,m.y,m.z).normalize();
        const ty = Math.atan2(v.x, v.z);
        const tx = Math.asin(THREE.MathUtils.clamp(v.y, -1, 1));

        yaw   = THREE.MathUtils.lerp(yaw, ty, 0.06);
        pitch = THREE.MathUtils.lerp(pitch, -tx, 0.06);
        targetDist = THREE.MathUtils.lerp(targetDist, 260, 0.03);
      }
    }

    /* ================= ORBIT + VELOCITY ================= */
    function updateMeteors(dt){
      for(const m of meteors){
        m.px = m.x; m.py = m.y; m.pz = m.z;

        m.ang += ORBIT_SPEED * m.speed * (dt*60);
        const rr = m.r + Math.sin(m.ang*2.4 + m.rx)*26;
        m.x = Math.cos(m.ang)*rr + Math.sin(m.ang*3.1)*22;
        m.z = Math.sin(m.ang)*rr + Math.cos(m.ang*2.7)*18;
        m.y = m.y*0.999 + Math.sin(m.ang*2.0 + m.ry)*0.22;

        m.ry += m.spin * (dt*60);

        m.vx = (m.x - m.px) / Math.max(dt, 0.0001);
        m.vy = (m.y - m.py) / Math.max(dt, 0.0001);
        m.vz = (m.z - m.pz) / Math.max(dt, 0.0001);
      }
    }

    /* ================= FIND 20 NEAREST & RENDER ================= */
    const camPos = new THREE.Vector3();
    const tmp = new THREE.Vector3();
    const tmp2 = new THREE.Vector3();

    function renderNearest20(){
      camera.getWorldPosition(camPos);
      world.updateMatrixWorld(true);

      const arr = [];
      for(let i=0;i<meteors.length;i++){
        const m = meteors[i];
        tmp.set(m.x,m.y,m.z).applyMatrix4(world.matrixWorld);
        const d2 = tmp.distanceToSquared(camPos);
        arr.push([d2,i,tmp.x,tmp.y,tmp.z]);
      }
      arr.sort((a,b)=>a[0]-b[0]);
      const nearest = arr.slice(0, MAX_RENDER);

      for(let p=0;p<MAX_RENDER;p++){
        const mesh = pool[p];
        const glow = poolGlow[p];
        const trail = poolTrail[p];

        const item = nearest[p];
        if(!item){
          mesh.visible=false; glow.visible=false; trail.visible=false; continue;
        }

        const idx = item[1];
        const wx = item[2], wy = item[3], wz = item[4];
        const m = meteors[idx];
        mesh.userData.dataIndex = idx;

        const tex = photoTex[m.photoId];
        if(tex && mesh.material.map !== tex){
          mesh.material.map = tex;
          mesh.material.needsUpdate = true;
        }

        mesh.position.set(wx,wy,wz);

        // biar nggak kerasa ‚Äú2D‚Äù: meteor punya rotasi sendiri
        mesh.rotation.set(m.rx, m.ry, m.rz);

        const distToCam = Math.sqrt(item[0]);

        // scale dekat lebih besar
        const scale = THREE.MathUtils.clamp(1.35 - (distToCam/860), 0.22, 1.10);
        mesh.scale.setScalar(scale);

        // fade jauh
        const alpha = THREE.MathUtils.clamp(1.0 - (distToCam/1200), 0.05, 1.0);
        mesh.material.opacity = alpha;

        mesh.visible = true;

        // glow
        glow.position.copy(mesh.position);
        glow.rotation.copy(mesh.rotation);
        glow.scale.setScalar(scale);
        glow.material.opacity = 0.18 * alpha;
        glow.visible = true;

        // ‚òÑÔ∏è TRAIL (fake glow trail)
        // arah trail = kebalikan velocity (world rotated)
        tmp.set(m.vx, m.vy, m.vz).normalize();
        // transform direction by world rotation (approx)
        tmp2.copy(tmp).applyEuler(world.rotation);

        const len = THREE.MathUtils.clamp((Math.abs(m.vx)+Math.abs(m.vy)+Math.abs(m.vz))*0.00035, 0.6, 3.0);
        trail.position.copy(mesh.position).addScaledVector(tmp2, -14*scale);
        trail.lookAt(trail.position.clone().addScaledVector(tmp2, -1));
        trail.scale.set(scale, scale*len, 1);
        trail.material.opacity = 0.10 * alpha;
        trail.visible = true;

        // kalau follow target: bikin lebih ‚Äúfull‚Äù
        if(idx === followIndex){
          mesh.material.opacity = Math.min(1, alpha+0.25);
          glow.material.opacity = Math.min(0.45, glow.material.opacity+0.20);
        }
      }

      // romantis muncul kalau dekat meteor yang lagi di-follow
      if(followIndex>=0){
        const m = meteors[followIndex];
        const line = loveLines.get(m.photoId) || "Aku peduli sama dirimu. ‚ù§Ô∏è";
        loveBox.innerHTML = `${line}<small>(foto ${m.photoId}.jpg)</small>`;
        loveBox.style.opacity = 1;
      } else {
        // kalau gak follow, hilangin pelan
        loveBox.style.opacity = 0;
      }

      hud.textContent = `Loaded ${loaded}/${TOTAL_PHOTO} ‚Ä¢ Render 20/${METEOR_COUNT} ‚Ä¢ Zoom ${dist.toFixed(0)} ‚Ä¢ Follow ${followIndex>=0 ? meteors[followIndex].photoId+".jpg" : "-"}`;
    }

    /* ================= SHUFFLE BUTTON (already set above) ================= */

    /* ================= MAIN LOOP ================= */
    function animate(){
      requestAnimationFrame(animate);
      const dt = clock.getDelta();

      updateCameraWorld(dt);
      updateMeteors(dt);
      renderNearest20();

      renderer.render(scene, camera);
    }
    animate();

  } catch(e){
    showErr(e);
  }
})();
</script>
</body>
</html>
